{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trace","text":"<p>Trace is a python application</p>"},{"location":"installation/","title":"Installing Trace","text":""},{"location":"api_reference/axis_table/","title":"Axis Table","text":""},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin","title":"<code>AxisTableMixin</code>","text":"<p>Mixins class for the Axes tab of the settings section.</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>class AxisTableMixin:\n    \"\"\"Mixins class for the Axes tab of the settings section.\"\"\"\n\n    def axis_table_init(self) -&gt; None:\n        \"\"\"Initializer for the Axis Table Model and Table View.\"\"\"\n        self.axis_table_model = ArchiverAxisModel(self.ui.main_plot, self)\n        self.ui.time_axis_tbl.setModel(self.axis_table_model)\n\n        hdr = self.ui.time_axis_tbl.horizontalHeader()\n        hdr.setSectionResizeMode(QHeaderView.Stretch)\n        del_col = self.axis_table_model.getColumnIndex(\"\")\n        hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n\n        plot_viewbox = self.ui.main_plot.plotItem.vb\n        plot_viewbox.sigXRangeChanged.connect(self.set_axis_datetimes)\n        plot_viewbox.sigRangeChangedManually.connect(lambda *_: self.set_axis_datetimes())\n\n        self.ui.main_start_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((qdt, None)))\n        self.ui.main_end_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((None, qdt)))\n\n        self.ui.add_axis_row_btn.clicked.connect(self.addAxis)\n\n    def axis_delegates_init(self) -&gt; None:\n        \"\"\"Initialize and set the ItemDelegates for the axis table.\"\"\"\n        orientation_col = self.axis_table_model.getColumnIndex(\"Y-Axis Orientation\")\n        orientation_map = {\"Left\": \"left\", \"Right\": \"right\"}\n        orientation_del = ComboBoxDelegate(self.ui.time_axis_tbl, orientation_map)\n        self.ui.time_axis_tbl.setItemDelegateForColumn(orientation_col, orientation_del)\n\n        min_range_col = self.axis_table_model.getColumnIndex(\"Min Y Range\")\n        min_range_del = ScientificNotationDelegate(self.ui.time_axis_tbl)\n        self.ui.time_axis_tbl.setItemDelegateForColumn(min_range_col, min_range_del)\n\n        max_range_col = self.axis_table_model.getColumnIndex(\"Max Y Range\")\n        max_range_del = ScientificNotationDelegate(self.ui.time_axis_tbl)\n        self.ui.time_axis_tbl.setItemDelegateForColumn(max_range_col, max_range_del)\n\n        delete_col = self.axis_table_model.getColumnIndex(\"\")\n        delete_row_del = DeleteRowDelegate(self.ui.time_axis_tbl)\n        self.ui.time_axis_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n\n    Slot(object)\n\n    def set_time_axis_range(self, raw_range: Tuple[QDateTime, QDateTime] = (None, None)) -&gt; None:\n        \"\"\"PyQT Slot to set the plot's X-Axis range. This slot should be\n        triggered on QDateTimeEdit value change.\n\n        Parameters\n        ----------\n        raw_range : Tuple[QDateTime], optional\n            Takes in a tuple of 2 values, where one is a QDateTime and\n            the other is None. The positioning changes either the plot's\n            min or max range value. By default (None, None)\n        \"\"\"\n        # Disable Autoscroll if enabled\n        self.ui.cursor_scale_btn.click()\n\n        proc_range = [None, None]\n        for ind, val in enumerate(raw_range):\n            # Values that are QDateTime are converted to a float timestamp\n            if isinstance(val, QDateTime):\n                proc_range[ind] = val.toSecsSinceEpoch()\n            # Values that are None use the existing range value\n            elif not val:\n                proc_range[ind] = self.ui.main_plot.getXAxis().range[ind]\n        proc_range.sort()\n\n        logger.debug(f\"Setting plot's X-Axis range to {proc_range}\")\n        self.ui.main_plot.plotItem.vb.blockSignals(True)\n        self.ui.main_plot.plotItem.setXRange(*proc_range)\n        self.ui.main_plot.plotItem.vb.blockSignals(False)\n\n    @Slot(object, object)\n    def set_axis_datetimes(self, _: ViewBox = None, time_range: Tuple[float, float] = None) -&gt; None:\n        \"\"\"Slot used to update the QDateTimeEdits on the Axis tab. This\n        slot is called when the plot's X-Axis range changes values.\n\n        Parameters\n        ----------\n        _ : ViewBox, optional\n            The ViewBox on which the range is changing. This is unused\n        time_range : Tuple[float, float], optional\n            The new range values for the QDateTimeEdits, by default None\n        \"\"\"\n        if not time_range:\n            time_range = self.ui.main_plot.getXAxis().range\n        if min(time_range) &lt;= 0:\n            return\n\n        time_range = [datetime.fromtimestamp(f) for f in time_range]\n\n        edits = (self.ui.main_start_datetime, self.ui.main_end_datetime)\n        for ind, qdt in enumerate(edits):\n            if qdt.hasFocus():\n                continue\n            qdt.blockSignals(True)\n            qdt.setDateTime(QDateTime(time_range[ind]))\n            qdt.blockSignals(False)\n\n    @Slot()\n    def addAxis(self) -&gt; None:\n        \"\"\"Slot for button to add a new row to the axis table.\"\"\"\n        self.axis_table_model.append()\n</code></pre>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.addAxis","title":"<code>addAxis()</code>","text":"<p>Slot for button to add a new row to the axis table.</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>@Slot()\ndef addAxis(self) -&gt; None:\n    \"\"\"Slot for button to add a new row to the axis table.\"\"\"\n    self.axis_table_model.append()\n</code></pre>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.axis_delegates_init","title":"<code>axis_delegates_init()</code>","text":"<p>Initialize and set the ItemDelegates for the axis table.</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>def axis_delegates_init(self) -&gt; None:\n    \"\"\"Initialize and set the ItemDelegates for the axis table.\"\"\"\n    orientation_col = self.axis_table_model.getColumnIndex(\"Y-Axis Orientation\")\n    orientation_map = {\"Left\": \"left\", \"Right\": \"right\"}\n    orientation_del = ComboBoxDelegate(self.ui.time_axis_tbl, orientation_map)\n    self.ui.time_axis_tbl.setItemDelegateForColumn(orientation_col, orientation_del)\n\n    min_range_col = self.axis_table_model.getColumnIndex(\"Min Y Range\")\n    min_range_del = ScientificNotationDelegate(self.ui.time_axis_tbl)\n    self.ui.time_axis_tbl.setItemDelegateForColumn(min_range_col, min_range_del)\n\n    max_range_col = self.axis_table_model.getColumnIndex(\"Max Y Range\")\n    max_range_del = ScientificNotationDelegate(self.ui.time_axis_tbl)\n    self.ui.time_axis_tbl.setItemDelegateForColumn(max_range_col, max_range_del)\n\n    delete_col = self.axis_table_model.getColumnIndex(\"\")\n    delete_row_del = DeleteRowDelegate(self.ui.time_axis_tbl)\n    self.ui.time_axis_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n</code></pre>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.axis_table_init","title":"<code>axis_table_init()</code>","text":"<p>Initializer for the Axis Table Model and Table View.</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>def axis_table_init(self) -&gt; None:\n    \"\"\"Initializer for the Axis Table Model and Table View.\"\"\"\n    self.axis_table_model = ArchiverAxisModel(self.ui.main_plot, self)\n    self.ui.time_axis_tbl.setModel(self.axis_table_model)\n\n    hdr = self.ui.time_axis_tbl.horizontalHeader()\n    hdr.setSectionResizeMode(QHeaderView.Stretch)\n    del_col = self.axis_table_model.getColumnIndex(\"\")\n    hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n\n    plot_viewbox = self.ui.main_plot.plotItem.vb\n    plot_viewbox.sigXRangeChanged.connect(self.set_axis_datetimes)\n    plot_viewbox.sigRangeChangedManually.connect(lambda *_: self.set_axis_datetimes())\n\n    self.ui.main_start_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((qdt, None)))\n    self.ui.main_end_datetime.dateTimeChanged.connect(lambda qdt: self.set_time_axis_range((None, qdt)))\n\n    self.ui.add_axis_row_btn.clicked.connect(self.addAxis)\n</code></pre>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.set_axis_datetimes","title":"<code>set_axis_datetimes(_=None, time_range=None)</code>","text":"<p>Slot used to update the QDateTimeEdits on the Axis tab. This slot is called when the plot's X-Axis range changes values.</p>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.set_axis_datetimes--parameters","title":"Parameters","text":"<p>_ : ViewBox, optional     The ViewBox on which the range is changing. This is unused time_range : Tuple[float, float], optional     The new range values for the QDateTimeEdits, by default None</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>@Slot(object, object)\ndef set_axis_datetimes(self, _: ViewBox = None, time_range: Tuple[float, float] = None) -&gt; None:\n    \"\"\"Slot used to update the QDateTimeEdits on the Axis tab. This\n    slot is called when the plot's X-Axis range changes values.\n\n    Parameters\n    ----------\n    _ : ViewBox, optional\n        The ViewBox on which the range is changing. This is unused\n    time_range : Tuple[float, float], optional\n        The new range values for the QDateTimeEdits, by default None\n    \"\"\"\n    if not time_range:\n        time_range = self.ui.main_plot.getXAxis().range\n    if min(time_range) &lt;= 0:\n        return\n\n    time_range = [datetime.fromtimestamp(f) for f in time_range]\n\n    edits = (self.ui.main_start_datetime, self.ui.main_end_datetime)\n    for ind, qdt in enumerate(edits):\n        if qdt.hasFocus():\n            continue\n        qdt.blockSignals(True)\n        qdt.setDateTime(QDateTime(time_range[ind]))\n        qdt.blockSignals(False)\n</code></pre>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.set_time_axis_range","title":"<code>set_time_axis_range(raw_range=(None, None))</code>","text":"<p>PyQT Slot to set the plot's X-Axis range. This slot should be triggered on QDateTimeEdit value change.</p>"},{"location":"api_reference/axis_table/#mixins.axis_table.AxisTableMixin.set_time_axis_range--parameters","title":"Parameters","text":"<p>raw_range : Tuple[QDateTime], optional     Takes in a tuple of 2 values, where one is a QDateTime and     the other is None. The positioning changes either the plot's     min or max range value. By default (None, None)</p> Source code in <code>trace/mixins/axis_table.py</code> <pre><code>def set_time_axis_range(self, raw_range: Tuple[QDateTime, QDateTime] = (None, None)) -&gt; None:\n    \"\"\"PyQT Slot to set the plot's X-Axis range. This slot should be\n    triggered on QDateTimeEdit value change.\n\n    Parameters\n    ----------\n    raw_range : Tuple[QDateTime], optional\n        Takes in a tuple of 2 values, where one is a QDateTime and\n        the other is None. The positioning changes either the plot's\n        min or max range value. By default (None, None)\n    \"\"\"\n    # Disable Autoscroll if enabled\n    self.ui.cursor_scale_btn.click()\n\n    proc_range = [None, None]\n    for ind, val in enumerate(raw_range):\n        # Values that are QDateTime are converted to a float timestamp\n        if isinstance(val, QDateTime):\n            proc_range[ind] = val.toSecsSinceEpoch()\n        # Values that are None use the existing range value\n        elif not val:\n            proc_range[ind] = self.ui.main_plot.getXAxis().range[ind]\n    proc_range.sort()\n\n    logger.debug(f\"Setting plot's X-Axis range to {proc_range}\")\n    self.ui.main_plot.plotItem.vb.blockSignals(True)\n    self.ui.main_plot.plotItem.setXRange(*proc_range)\n    self.ui.main_plot.plotItem.vb.blockSignals(False)\n</code></pre>"},{"location":"api_reference/plot_config/","title":"Plot Config","text":""},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin","title":"<code>PlotConfigMixin</code>","text":"Source code in <code>trace/mixins/plot_config.py</code> <pre><code>class PlotConfigMixin:\n    def plot_config_init(self):\n        \"\"\"Load the widgets of the plot config tab programmatically\n        All of the other functions in this class are not really going to be called, they are simply the slots\n        for each of these widgets to connect to internally.\n        \"\"\"\n\n        self.plot = self.ui.main_plot\n        self.ui.plot_title_edit.textChanged.connect(self.plot.setPlotTitle)\n\n        self.ui.x_grid_chckbx.stateChanged.connect(self.show_x_grid)\n\n        self.ui.y_grid_chckbx.stateChanged.connect(self.show_y_grid)\n\n        self.ui.opacity_sldr.valueChanged.connect(self.change_opacity)\n        self.ui.xafs_spnbx.setValue(12)\n        self.ui.xafs_spnbx.valueChanged.connect(self.set_font_size)\n        self.background_color_button = ColorButton(color=\"white\")\n        self.ui.background_color_lyt.insertWidget(1, self.background_color_button)\n        self.background_color_button.color_changed.connect(self.plot.setBackgroundColor)\n\n        self.ui.refresh_interval_spnbx.setValue(5)\n        self.ui.refresh_interval_spnbx.valueChanged.connect(lambda interval: self.autoScroll(enable=True))\n\n        self.ui.legend_chckbx.stateChanged.connect(self.plot.setShowLegend)\n\n        self.ui.crosshair_chckbx.stateChanged.connect(lambda show: self.plot.enableCrosshair(show, 100, 100))\n\n        self.ui.mouse_mode_cmbbx.currentIndexChanged.connect(self.changeMouseMode)\n\n    def plot_setup(self, config: Dict):\n        \"\"\"Read in the full config dictionary, making sure not to fail if a user manually typed\n        the import file out. For each config preset, set the widgets to match the value, which will\n        send signals out that will actually cause the plot to change\"\"\"\n        if \"title\" in config:\n            self.ui.plot_title_edit.setText(config[\"title\"])\n        if \"xGrid\" in config:\n            self.ui.x_grid_chckbx.setChecked(config[\"xGrid\"])\n        if \"yGrid\" in config:\n            self.ui.y_grid_chckbx.setChecked(config[\"yGrid\"])\n        if \"opacity\" in config:\n            self.ui.opacity_sldr.setValue(config[\"opacity\"])\n        if \"backgroundColor\" in config:\n            self.background_color_button.color = QColor(config[\"backgroundColor\"])\n        if \"legend\" in config:\n            self.ui.legend_chckbx.setChecked(config[\"legend\"])\n        if \"mouseMode\" in config:\n            self.ui.mouse_mode_cmbbx.setCurrentIndex(int(config[\"mouseMode\"] / 3))\n        if \"crosshair\" in config:\n            self.ui.crosshair_chckbx.setChecked(config[\"crosshair\"])\n        if \"refreshInterval\" in config:\n            self.ui.refresh_interval_spnbx.setValue(config[\"refreshInterval\"])\n\n    @Slot(int)\n    def set_font_size(self, size: int):\n        font = QFont()\n        font.setPixelSize(size)\n        self.plot.getAxis(\"bottom\").setStyle(tickFont=font)\n\n    @Slot(int)\n    def changeMouseMode(self, mode: int):\n        \"\"\"If the user wants to have their mouse in PAN or RECT mode\"\"\"\n        mouse_mode = ViewBox.RectMode\n        if mode == 1:\n            mouse_mode = ViewBox.PanMode\n        self.plot.plotItem.getViewBox().setMouseMode(mouse_mode)\n\n    @Slot()\n    def autoScroll(self, enable: bool = False):\n        \"\"\"Set the autoscroll to the given timespan and selected refresh interval\"\"\"\n        refresh_interval = int(self.ui.refresh_interval_spnbx.value() * 1000)\n        self.plot.setAutoScroll(enable=enable, timespan=self.timespan, refresh_rate=refresh_interval)\n\n    @Slot(int)\n    def change_opacity(self, opacity: int):\n        \"\"\"Set opacity of gridLines via slider\"\"\"\n        x_visible = self.ui.x_grid_chckbx.isChecked()\n        y_visible = self.ui.y_grid_chckbx.isChecked()\n\n        opacity /= 100.0\n        self.plot.setShowXGrid(x_visible, opacity)\n        self.plot.setShowYGrid(y_visible, opacity)\n\n    @Slot(int)\n    def show_x_grid(self, visible: bool):\n        \"\"\"Set the x grid visible or not based on user checking the corresponding box\"\"\"\n        opacity = self.ui.opacity_sldr.value() / 100.0\n        self.plot.setShowXGrid(visible, opacity)\n\n    @Slot(int)\n    def show_y_grid(self, visible: bool):\n        \"\"\"Set the y grid visible or not based on user checking the corresponding box\"\"\"\n        opacity = self.ui.opacity_sldr.value() / 100.0\n        self.plot.setShowYGrid(visible, opacity)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.autoScroll","title":"<code>autoScroll(enable=False)</code>","text":"<p>Set the autoscroll to the given timespan and selected refresh interval</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>@Slot()\ndef autoScroll(self, enable: bool = False):\n    \"\"\"Set the autoscroll to the given timespan and selected refresh interval\"\"\"\n    refresh_interval = int(self.ui.refresh_interval_spnbx.value() * 1000)\n    self.plot.setAutoScroll(enable=enable, timespan=self.timespan, refresh_rate=refresh_interval)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.changeMouseMode","title":"<code>changeMouseMode(mode)</code>","text":"<p>If the user wants to have their mouse in PAN or RECT mode</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>@Slot(int)\ndef changeMouseMode(self, mode: int):\n    \"\"\"If the user wants to have their mouse in PAN or RECT mode\"\"\"\n    mouse_mode = ViewBox.RectMode\n    if mode == 1:\n        mouse_mode = ViewBox.PanMode\n    self.plot.plotItem.getViewBox().setMouseMode(mouse_mode)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.change_opacity","title":"<code>change_opacity(opacity)</code>","text":"<p>Set opacity of gridLines via slider</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>@Slot(int)\ndef change_opacity(self, opacity: int):\n    \"\"\"Set opacity of gridLines via slider\"\"\"\n    x_visible = self.ui.x_grid_chckbx.isChecked()\n    y_visible = self.ui.y_grid_chckbx.isChecked()\n\n    opacity /= 100.0\n    self.plot.setShowXGrid(x_visible, opacity)\n    self.plot.setShowYGrid(y_visible, opacity)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.plot_config_init","title":"<code>plot_config_init()</code>","text":"<p>Load the widgets of the plot config tab programmatically All of the other functions in this class are not really going to be called, they are simply the slots for each of these widgets to connect to internally.</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>def plot_config_init(self):\n    \"\"\"Load the widgets of the plot config tab programmatically\n    All of the other functions in this class are not really going to be called, they are simply the slots\n    for each of these widgets to connect to internally.\n    \"\"\"\n\n    self.plot = self.ui.main_plot\n    self.ui.plot_title_edit.textChanged.connect(self.plot.setPlotTitle)\n\n    self.ui.x_grid_chckbx.stateChanged.connect(self.show_x_grid)\n\n    self.ui.y_grid_chckbx.stateChanged.connect(self.show_y_grid)\n\n    self.ui.opacity_sldr.valueChanged.connect(self.change_opacity)\n    self.ui.xafs_spnbx.setValue(12)\n    self.ui.xafs_spnbx.valueChanged.connect(self.set_font_size)\n    self.background_color_button = ColorButton(color=\"white\")\n    self.ui.background_color_lyt.insertWidget(1, self.background_color_button)\n    self.background_color_button.color_changed.connect(self.plot.setBackgroundColor)\n\n    self.ui.refresh_interval_spnbx.setValue(5)\n    self.ui.refresh_interval_spnbx.valueChanged.connect(lambda interval: self.autoScroll(enable=True))\n\n    self.ui.legend_chckbx.stateChanged.connect(self.plot.setShowLegend)\n\n    self.ui.crosshair_chckbx.stateChanged.connect(lambda show: self.plot.enableCrosshair(show, 100, 100))\n\n    self.ui.mouse_mode_cmbbx.currentIndexChanged.connect(self.changeMouseMode)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.plot_setup","title":"<code>plot_setup(config)</code>","text":"<p>Read in the full config dictionary, making sure not to fail if a user manually typed the import file out. For each config preset, set the widgets to match the value, which will send signals out that will actually cause the plot to change</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>def plot_setup(self, config: Dict):\n    \"\"\"Read in the full config dictionary, making sure not to fail if a user manually typed\n    the import file out. For each config preset, set the widgets to match the value, which will\n    send signals out that will actually cause the plot to change\"\"\"\n    if \"title\" in config:\n        self.ui.plot_title_edit.setText(config[\"title\"])\n    if \"xGrid\" in config:\n        self.ui.x_grid_chckbx.setChecked(config[\"xGrid\"])\n    if \"yGrid\" in config:\n        self.ui.y_grid_chckbx.setChecked(config[\"yGrid\"])\n    if \"opacity\" in config:\n        self.ui.opacity_sldr.setValue(config[\"opacity\"])\n    if \"backgroundColor\" in config:\n        self.background_color_button.color = QColor(config[\"backgroundColor\"])\n    if \"legend\" in config:\n        self.ui.legend_chckbx.setChecked(config[\"legend\"])\n    if \"mouseMode\" in config:\n        self.ui.mouse_mode_cmbbx.setCurrentIndex(int(config[\"mouseMode\"] / 3))\n    if \"crosshair\" in config:\n        self.ui.crosshair_chckbx.setChecked(config[\"crosshair\"])\n    if \"refreshInterval\" in config:\n        self.ui.refresh_interval_spnbx.setValue(config[\"refreshInterval\"])\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.show_x_grid","title":"<code>show_x_grid(visible)</code>","text":"<p>Set the x grid visible or not based on user checking the corresponding box</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>@Slot(int)\ndef show_x_grid(self, visible: bool):\n    \"\"\"Set the x grid visible or not based on user checking the corresponding box\"\"\"\n    opacity = self.ui.opacity_sldr.value() / 100.0\n    self.plot.setShowXGrid(visible, opacity)\n</code></pre>"},{"location":"api_reference/plot_config/#mixins.plot_config.PlotConfigMixin.show_y_grid","title":"<code>show_y_grid(visible)</code>","text":"<p>Set the y grid visible or not based on user checking the corresponding box</p> Source code in <code>trace/mixins/plot_config.py</code> <pre><code>@Slot(int)\ndef show_y_grid(self, visible: bool):\n    \"\"\"Set the y grid visible or not based on user checking the corresponding box\"\"\"\n    opacity = self.ui.opacity_sldr.value() / 100.0\n    self.plot.setShowYGrid(visible, opacity)\n</code></pre>"},{"location":"api_reference/trace/","title":"Trace","text":"<p>The main startup file for trace.</p> <p>This file can be launched directly from PyDM: <code>pydm trace/main.py</code></p>"},{"location":"api_reference/trace/#arguments-and-macros","title":"Arguments and Macros","text":"<p>Arguments and macros are parsed in this file. Valid arguments include: - -h, --help:     - Show the help message - -i INPUT_FILE, --input_file INPUT_FILE:     - File path to import from     - Alternatively can be passed as INPUT_FILE macro     - e.g. <code>pydm trace/main.py -i trace/examples/FormulaExample.trc</code> - -p PV1 PV2 ..., --pvs PV1 PV2 ...:     - List of PVs to show on startup     - Alternatively can be passed as PV or PVS macros     - Takes string(s) representing the channels to connect to     - e.g. <code>pydm trace/main.py -p FOO:BAR:CHANNEL SOME:OTHER:CHANNEL</code></p>"},{"location":"api_reference/trace/#main.TraceDisplay","title":"<code>TraceDisplay</code>","text":"<p>               Bases: <code>Display</code>, <code>TracesTableMixin</code>, <code>AxisTableMixin</code>, <code>FileIOMixin</code>, <code>PlotConfigMixin</code></p> Source code in <code>trace/main.py</code> <pre><code>class TraceDisplay(Display, TracesTableMixin, AxisTableMixin, FileIOMixin, PlotConfigMixin):\n    def __init__(self, parent=None, args=None, macros=None, ui_filename=__file__.replace(\".py\", \".ui\")) -&gt; None:\n        super(TraceDisplay, self).__init__(parent=parent, args=args, macros=macros, ui_filename=ui_filename)\n        # Set up PyDMApplication\n        self.configure_app()\n        self.set_footer()\n\n        # Initialize the Mixins\n        self.axis_table_init()\n        self.traces_table_init()\n        self.plot_config_init()\n        self.file_io_init()\n\n        self.curve_delegates_init()\n        self.axis_delegates_init()\n        self.timespan = -1\n        self.axis_table_model.reset_everything.connect(self.resetPlot)\n        # Create reference dict for timespan_btns button group\n        self.button_spans = {\n            self.ui.half_min_scale_btn: 30,\n            self.ui.min_scale_btn: 60,\n            self.ui.hour_scale_btn: 3600,\n            self.ui.week_scale_btn: 604800,\n            self.ui.month_scale_btn: 2628300,\n            self.ui.cursor_scale_btn: -1,\n        }\n        self.ui.timespan_btns.buttonClicked.connect(self.set_plot_timerange)\n\n        # Click \"Cursor\" button on plot-mouse interaction\n        plot_viewbox = self.ui.main_plot.plotItem.vb\n        plot_viewbox.sigRangeChangedManually.connect(self.ui.cursor_scale_btn.click)\n\n        # Parse macros &amp; arguments, then include them in startup\n        input_file, startup_pvs = self.parse_macros_and_args(macros, args)\n        if input_file:\n            self.import_save_file(input_file)\n        for pv in startup_pvs:\n            if pv in self.curves_model:\n                continue\n            last_row = self.curves_model.rowCount() - 1\n            index = self.curves_model.index(last_row, 0)\n            self.curves_model.setData(index, pv, Qt.EditRole)\n\n    def menu_items(self) -&gt; dict:\n        \"\"\"Add export &amp; import functionality to File menu\"\"\"\n        return {\"Export\": (self.export_save_file, \"Ctrl+S\"), \"Import\": (self.import_save_file, \"Ctrl+L\")}\n\n    def configure_app(self):\n        \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n        app = QApplication.instance()\n\n        # Hide navigation bar by default (can be shown in menu bar)\n        app.main_window.toggle_nav_bar(False)\n        app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n        # Hide status bar by default (can be shown in menu bar)\n        app.main_window.toggle_status_bar(False)\n        app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n        # Add style to center checkboxes in table cells\n        app.setStyle(CenterCheckStyle())\n\n        # Adjust settings for main_spltr\n        self.ui.main_spltr.setSizes([1, 200])\n        self.ui.main_spltr.setCollapsible(0, False)\n        self.ui.main_spltr.setStretchFactor(0, 1)\n\n    def set_footer(self):\n        \"\"\"Set footer information for application. Includes logging, nodename,\n        username, PID, git version, Archiver URL, and current datetime\n        \"\"\"\n        self.logging_handler = LoggingHandler(self.ui.ftr_logging_lbl)\n        logger.addHandler(self.logging_handler)\n        logger.setLevel(\"NOTSET\")\n\n        self.ui.ftr_node_lbl.setText(os.uname().nodename)\n        self.ui.ftr_user_lbl.setText(os.getlogin())\n        self.ui.ftr_pid_lbl.setText(str(os.getpid()))\n        self.ui.ftr_ver_lbl.setText(self.git_version())\n        self.ui.ftr_url_lbl.setText(os.getenv(\"PYDM_ARCHIVER_URL\"))\n        self.ui.ftr_time_lbl.channel = \"ca://\" + datetime_pv\n\n    def parse_macros_and_args(self, macros: Dict[str, str | list], args: List[str]) -&gt; Tuple[str, list]:\n        \"\"\"Parse user provided macros and args into lists of PVs to use on\n        startup or which file to import on startup\n\n        Parameters\n        ----------\n        macros : Dict[str, str | list]\n            Dictionary containing all of the macros passed into PyDM\n        args : List[str]\n            List of all arguments passed into the application to be parsed\n\n        Returns\n        -------\n        tuple\n            A tuple containing the file to import from and the list of PVs to use on startup\n        \"\"\"\n        # Default macros is None\n        if not macros:\n            macros = {}\n\n        # Construct an argument parser for args\n        trace_parser = argparse.ArgumentParser(\n            description=\"Trace\\nThis is a PyDM application \" + \"used to display archived and live pv data.\",\n            formatter_class=argparse.RawTextHelpFormatter,\n        )\n        trace_parser.add_argument(\n            \"-i\",\n            \"--input_file\",\n            action=PathAction,\n            type=str,\n            default=\"\",\n            help=\"Absolute file path to import from;\\n\" + \"Alternatively can be provided as INPUT_FILE macro\",\n        )\n        trace_parser.add_argument(\n            \"-p\",\n            \"--pvs\",\n            type=str,\n            nargs=\"*\",\n            default=[],\n            help=\"List of PVs to show on startup;\\n\" + \"Alternatively can be provided as PV or PVS macros\",\n        )\n\n        # Parse arguments and ignore unknowns\n        trace_args, unknown = trace_parser.parse_known_args(args)\n        for u in unknown:\n            if not u:\n                continue\n            logger.warning(f\"Not using unknown arguments: {u}\")\n\n        # Get the file to import from if one is provided. Prioritize args over macro\n        input_file = trace_args.input_file\n        if not input_file and \"INPUT_FILE\" in macros:\n            input_file = macros[\"INPUT_FILE\"]\n\n        # Get the list of PVs to show on startup\n        startup_pvs = []\n        for key in (\"PV\", \"PVS\"):\n            if key in macros:\n                val = macros[key]\n                if isinstance(val, str):\n                    startup_pvs.append(val)\n                elif isinstance(val, list):\n                    startup_pvs += val\n        startup_pvs += trace_args.pvs\n\n        # Remove duplicates from startup_pvs\n        startup_pvs = list(dict.fromkeys(startup_pvs))\n\n        return (input_file, startup_pvs)\n\n    @staticmethod\n    def git_version():\n        \"\"\"Get the current git tag for the project\"\"\"\n        project_directory = __file__.rsplit(\"/\", 1)[0]\n        git_cmd = run(f\"cd {project_directory} &amp;&amp; git describe --tags\", text=True, shell=True, capture_output=True)\n        return git_cmd.stdout.strip()\n\n    @Slot()\n    def resetPlot(self) -&gt; None:\n        \"\"\"Reset the Axis model and the Curve model to empty states\"\"\"\n        self.axis_table_model.set_model_axes()\n        self.curves_model.set_model_curves()\n\n    @Slot(QAbstractButton)\n    def set_plot_timerange(self, button: QAbstractButton) -&gt; None:\n        \"\"\"Slot to be called when a timespan setting button is pressed.\n        This will enable autoscrolling along the x-axis and disable mouse\n        controls. If the \"Cursor\" button is pressed, then autoscrolling is\n        disabled and mouse controls are enabled.\n\n        Parameters\n        ----------\n        button : QAbstractButton\n            The timespan setting button pressed. Determines which timespan\n            to set.\n        \"\"\"\n        logger.debug(\"Setting plot timerange\")\n        if button not in self.button_spans:\n            logger.error(f\"{button} is not a valid timespan button\")\n            return\n        enable_scroll = button != self.ui.cursor_scale_btn\n        self.timespan = self.button_spans[button]\n        if enable_scroll:\n            logger.debug(f\"Enabling plot autoscroll for {self.timespan}s\")\n        else:\n            logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n        self.autoScroll(enable=enable_scroll)\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.configure_app","title":"<code>configure_app()</code>","text":"<p>UI changes to be made to the PyDMApplication</p> Source code in <code>trace/main.py</code> <pre><code>def configure_app(self):\n    \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n    app = QApplication.instance()\n\n    # Hide navigation bar by default (can be shown in menu bar)\n    app.main_window.toggle_nav_bar(False)\n    app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n    # Hide status bar by default (can be shown in menu bar)\n    app.main_window.toggle_status_bar(False)\n    app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n    # Add style to center checkboxes in table cells\n    app.setStyle(CenterCheckStyle())\n\n    # Adjust settings for main_spltr\n    self.ui.main_spltr.setSizes([1, 200])\n    self.ui.main_spltr.setCollapsible(0, False)\n    self.ui.main_spltr.setStretchFactor(0, 1)\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.git_version","title":"<code>git_version()</code>  <code>staticmethod</code>","text":"<p>Get the current git tag for the project</p> Source code in <code>trace/main.py</code> <pre><code>@staticmethod\ndef git_version():\n    \"\"\"Get the current git tag for the project\"\"\"\n    project_directory = __file__.rsplit(\"/\", 1)[0]\n    git_cmd = run(f\"cd {project_directory} &amp;&amp; git describe --tags\", text=True, shell=True, capture_output=True)\n    return git_cmd.stdout.strip()\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.menu_items","title":"<code>menu_items()</code>","text":"<p>Add export &amp; import functionality to File menu</p> Source code in <code>trace/main.py</code> <pre><code>def menu_items(self) -&gt; dict:\n    \"\"\"Add export &amp; import functionality to File menu\"\"\"\n    return {\"Export\": (self.export_save_file, \"Ctrl+S\"), \"Import\": (self.import_save_file, \"Ctrl+L\")}\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.parse_macros_and_args","title":"<code>parse_macros_and_args(macros, args)</code>","text":"<p>Parse user provided macros and args into lists of PVs to use on startup or which file to import on startup</p>"},{"location":"api_reference/trace/#main.TraceDisplay.parse_macros_and_args--parameters","title":"Parameters","text":"<p>macros : Dict[str, str | list]     Dictionary containing all of the macros passed into PyDM args : List[str]     List of all arguments passed into the application to be parsed</p>"},{"location":"api_reference/trace/#main.TraceDisplay.parse_macros_and_args--returns","title":"Returns","text":"<p>tuple     A tuple containing the file to import from and the list of PVs to use on startup</p> Source code in <code>trace/main.py</code> <pre><code>def parse_macros_and_args(self, macros: Dict[str, str | list], args: List[str]) -&gt; Tuple[str, list]:\n    \"\"\"Parse user provided macros and args into lists of PVs to use on\n    startup or which file to import on startup\n\n    Parameters\n    ----------\n    macros : Dict[str, str | list]\n        Dictionary containing all of the macros passed into PyDM\n    args : List[str]\n        List of all arguments passed into the application to be parsed\n\n    Returns\n    -------\n    tuple\n        A tuple containing the file to import from and the list of PVs to use on startup\n    \"\"\"\n    # Default macros is None\n    if not macros:\n        macros = {}\n\n    # Construct an argument parser for args\n    trace_parser = argparse.ArgumentParser(\n        description=\"Trace\\nThis is a PyDM application \" + \"used to display archived and live pv data.\",\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n    trace_parser.add_argument(\n        \"-i\",\n        \"--input_file\",\n        action=PathAction,\n        type=str,\n        default=\"\",\n        help=\"Absolute file path to import from;\\n\" + \"Alternatively can be provided as INPUT_FILE macro\",\n    )\n    trace_parser.add_argument(\n        \"-p\",\n        \"--pvs\",\n        type=str,\n        nargs=\"*\",\n        default=[],\n        help=\"List of PVs to show on startup;\\n\" + \"Alternatively can be provided as PV or PVS macros\",\n    )\n\n    # Parse arguments and ignore unknowns\n    trace_args, unknown = trace_parser.parse_known_args(args)\n    for u in unknown:\n        if not u:\n            continue\n        logger.warning(f\"Not using unknown arguments: {u}\")\n\n    # Get the file to import from if one is provided. Prioritize args over macro\n    input_file = trace_args.input_file\n    if not input_file and \"INPUT_FILE\" in macros:\n        input_file = macros[\"INPUT_FILE\"]\n\n    # Get the list of PVs to show on startup\n    startup_pvs = []\n    for key in (\"PV\", \"PVS\"):\n        if key in macros:\n            val = macros[key]\n            if isinstance(val, str):\n                startup_pvs.append(val)\n            elif isinstance(val, list):\n                startup_pvs += val\n    startup_pvs += trace_args.pvs\n\n    # Remove duplicates from startup_pvs\n    startup_pvs = list(dict.fromkeys(startup_pvs))\n\n    return (input_file, startup_pvs)\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.resetPlot","title":"<code>resetPlot()</code>","text":"<p>Reset the Axis model and the Curve model to empty states</p> Source code in <code>trace/main.py</code> <pre><code>@Slot()\ndef resetPlot(self) -&gt; None:\n    \"\"\"Reset the Axis model and the Curve model to empty states\"\"\"\n    self.axis_table_model.set_model_axes()\n    self.curves_model.set_model_curves()\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.set_footer","title":"<code>set_footer()</code>","text":"<p>Set footer information for application. Includes logging, nodename, username, PID, git version, Archiver URL, and current datetime</p> Source code in <code>trace/main.py</code> <pre><code>def set_footer(self):\n    \"\"\"Set footer information for application. Includes logging, nodename,\n    username, PID, git version, Archiver URL, and current datetime\n    \"\"\"\n    self.logging_handler = LoggingHandler(self.ui.ftr_logging_lbl)\n    logger.addHandler(self.logging_handler)\n    logger.setLevel(\"NOTSET\")\n\n    self.ui.ftr_node_lbl.setText(os.uname().nodename)\n    self.ui.ftr_user_lbl.setText(os.getlogin())\n    self.ui.ftr_pid_lbl.setText(str(os.getpid()))\n    self.ui.ftr_ver_lbl.setText(self.git_version())\n    self.ui.ftr_url_lbl.setText(os.getenv(\"PYDM_ARCHIVER_URL\"))\n    self.ui.ftr_time_lbl.channel = \"ca://\" + datetime_pv\n</code></pre>"},{"location":"api_reference/trace/#main.TraceDisplay.set_plot_timerange","title":"<code>set_plot_timerange(button)</code>","text":"<p>Slot to be called when a timespan setting button is pressed. This will enable autoscrolling along the x-axis and disable mouse controls. If the \"Cursor\" button is pressed, then autoscrolling is disabled and mouse controls are enabled.</p>"},{"location":"api_reference/trace/#main.TraceDisplay.set_plot_timerange--parameters","title":"Parameters","text":"<p>button : QAbstractButton     The timespan setting button pressed. Determines which timespan     to set.</p> Source code in <code>trace/main.py</code> <pre><code>@Slot(QAbstractButton)\ndef set_plot_timerange(self, button: QAbstractButton) -&gt; None:\n    \"\"\"Slot to be called when a timespan setting button is pressed.\n    This will enable autoscrolling along the x-axis and disable mouse\n    controls. If the \"Cursor\" button is pressed, then autoscrolling is\n    disabled and mouse controls are enabled.\n\n    Parameters\n    ----------\n    button : QAbstractButton\n        The timespan setting button pressed. Determines which timespan\n        to set.\n    \"\"\"\n    logger.debug(\"Setting plot timerange\")\n    if button not in self.button_spans:\n        logger.error(f\"{button} is not a valid timespan button\")\n        return\n    enable_scroll = button != self.ui.cursor_scale_btn\n    self.timespan = self.button_spans[button]\n    if enable_scroll:\n        logger.debug(f\"Enabling plot autoscroll for {self.timespan}s\")\n    else:\n        logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n    self.autoScroll(enable=enable_scroll)\n</code></pre>"},{"location":"api_reference/traces_table/","title":"Traces Table","text":""},{"location":"api_reference/traces_table/#mixins.traces_table.FormulaDialog","title":"<code>FormulaDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Formula Dialog - when a user right clicks on a row in the list of curves, they have the option to input a formula. They could opt to type it instead, but this opens a box that is a nicer UI for inputting a formula.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>class FormulaDialog(QDialog):\n    \"\"\"Formula Dialog - when a user right clicks on a row in the list of\n    curves, they have the option to input a formula. They could opt to type it\n    instead, but this opens a box that is a nicer UI for inputting a formula.\n    \"\"\"\n\n    def __init__(self, parent: QObject) -&gt; None:\n        super().__init__(parent)\n        self.setWindowTitle(\"Formula Input\")\n\n        # Create the layout for the dialog\n        layout = QVBoxLayout(self)\n\n        # Create the QLineEdit for formula input\n        self.field = QLineEdit(self)\n\n        # Display list of channels from curve model as table\n        self.curveModel = self.parent().parent().curves_model\n        self.pv_list = QTableView(self)\n        self.pv_list.setModel(self.curveModel)\n        self.pv_list.setEditTriggers(QAbstractItemView.EditTriggers(0))\n        self.pv_list.setMaximumWidth(1000)\n        self.pv_list.setMaximumHeight(1000)\n\n        # Hide all columns unused. Leave one to add a button to\n        header = self.pv_list.horizontalHeader()\n        header.setSectionResizeMode(0, QHeaderView.Stretch)\n        for i in range(1, self.curveModel.columnCount() - 1):\n            self.pv_list.setColumnHidden(i, True)\n\n        insertButton = InsertPVDelegate(self.pv_list)\n        insertButton.button_clicked.connect(self.field.insert)\n        self.pv_list.setItemDelegateForColumn(self.curveModel.columnCount() - 1, insertButton)\n\n        layout.addWidget(self.pv_list)\n        layout.addWidget(self.field)\n\n        self.index = self.parent().selected_index\n\n        # Define the list of calculator buttons.\n        # It's a bunch of preset buttons, but users can type other functions under math.\n        # fmt: off\n        buttons = [\n            \"7\",   \"8\",      \"9\",      \"+\",       \"(\",      \")\",\n            \"4\",   \"5\",      \"6\",      \"-\",       \"^2\",     \"sqrt()\",\n            \"1\",   \"2\",      \"3\",      \"*\",       \"^-1\",    \"ln()\",\n            \"0\",   \"e\",      \"pi\",     \"/\",       \"sin()\",  \"asin()\",\n            \".\",   \"abs()\",  \"min()\",  \"^\",       \"cos()\",  \"acos()\",\n            \"PV\",  \"Clear\",  \"max()\",  \"mean()\",  \"tan()\",  \"atan()\",\n        ]\n        # fmt: on\n\n        # Create the calculator buttons and connect them to the input field\n        grid_layout = QGridLayout()\n        for i, button_text in enumerate(buttons):\n            button = QPushButton(button_text, self)\n            row = i // 6\n            col = i % 6\n            grid_layout.addWidget(button, row, col)\n            # Connect the button clicked signal to the appropriate action\n            # PV currently does nothing, this is a remnant\n            # From when we would have the pv_list open in a new window\n            if button_text == \"PV\":\n                self.PVButton = button\n                self.PVButton.setCheckable(True)\n                self.PVButton.setChecked(True)\n                self.PVButton.clicked.connect(self.showPVList)\n            elif button_text == \"Clear\":\n                button.clicked.connect(lambda _: self.field.clear())\n            else:\n                button.clicked.connect(lambda _, text=button_text: self.field.insert(text))\n        layout.addLayout(grid_layout)\n\n        # Add an \"OK\" button to accept the formula and close the dialog\n        ok_button = QPushButton(\"OK\", self)\n        ok_button.clicked.connect(self.accept_formula)\n        layout.addWidget(ok_button)\n        self.showPVList()\n\n    def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n        \"\"\"Special key press tracker. If enter or return is pressed the formula\n        dialog submits the formula.\n        \"\"\"\n        if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n            self.accept_formula()\n        return super().keyPressEvent(e)\n\n    @Slot()\n    def showPVList(self):\n        \"\"\"Hide or show the PV list on PVButton click.\"\"\"\n        show = self.PVButton.isChecked()\n        if show:\n            self.pv_list.show()\n        else:\n            self.pv_list.hide()\n\n    def exec_(self):\n        \"\"\"When the formula dialog is opened, get the latest information from\n        the curve model. If a formula already exists for the selected index,\n        then populate the text box with the existing formula.\n        \"\"\"\n        self.index = self.parent().selected_index\n        self.pv_list.setRowHidden(len(self.curveModel._row_names) - 1, True)\n        for i in range(self.curveModel.rowCount() - 1):\n            self.pv_list.setRowHidden(i, False)\n        index = self.curveModel.index(self.index.row(), 0)\n        curve = self.curveModel._plot._curves[self.index.row()]\n        if index.data() and isinstance(curve, FormulaCurveItem):\n            self.field.setText(str(index.data()).strip(\"f://\"))\n        else:\n            self.field.setText(\"\")\n        super().exec_()\n\n    @Slot()\n    def accept_formula(self) -&gt; None:\n        \"\"\"Set the curve in the curve model to use the entered formula. If the\n        formula is invalid, then the dialog box is closed.\n        \"\"\"\n        formula = \"f://\" + self.field.text()\n        passed = self.curveModel.set_data(\n            column_name=\"Channel\",\n            curve=self.curveModel._plot._curves[self.parent().selected_index.row()],\n            value=formula,\n        )\n        if passed:\n            self.field.setText(\"\")\n            self.accept()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.FormulaDialog.accept_formula","title":"<code>accept_formula()</code>","text":"<p>Set the curve in the curve model to use the entered formula. If the formula is invalid, then the dialog box is closed.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>@Slot()\ndef accept_formula(self) -&gt; None:\n    \"\"\"Set the curve in the curve model to use the entered formula. If the\n    formula is invalid, then the dialog box is closed.\n    \"\"\"\n    formula = \"f://\" + self.field.text()\n    passed = self.curveModel.set_data(\n        column_name=\"Channel\",\n        curve=self.curveModel._plot._curves[self.parent().selected_index.row()],\n        value=formula,\n    )\n    if passed:\n        self.field.setText(\"\")\n        self.accept()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.FormulaDialog.exec_","title":"<code>exec_()</code>","text":"<p>When the formula dialog is opened, get the latest information from the curve model. If a formula already exists for the selected index, then populate the text box with the existing formula.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def exec_(self):\n    \"\"\"When the formula dialog is opened, get the latest information from\n    the curve model. If a formula already exists for the selected index,\n    then populate the text box with the existing formula.\n    \"\"\"\n    self.index = self.parent().selected_index\n    self.pv_list.setRowHidden(len(self.curveModel._row_names) - 1, True)\n    for i in range(self.curveModel.rowCount() - 1):\n        self.pv_list.setRowHidden(i, False)\n    index = self.curveModel.index(self.index.row(), 0)\n    curve = self.curveModel._plot._curves[self.index.row()]\n    if index.data() and isinstance(curve, FormulaCurveItem):\n        self.field.setText(str(index.data()).strip(\"f://\"))\n    else:\n        self.field.setText(\"\")\n    super().exec_()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.FormulaDialog.keyPressEvent","title":"<code>keyPressEvent(e)</code>","text":"<p>Special key press tracker. If enter or return is pressed the formula dialog submits the formula.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n    \"\"\"Special key press tracker. If enter or return is pressed the formula\n    dialog submits the formula.\n    \"\"\"\n    if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n        self.accept_formula()\n    return super().keyPressEvent(e)\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.FormulaDialog.showPVList","title":"<code>showPVList()</code>","text":"<p>Hide or show the PV list on PVButton click.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>@Slot()\ndef showPVList(self):\n    \"\"\"Hide or show the PV list on PVButton click.\"\"\"\n    show = self.PVButton.isChecked()\n    if show:\n        self.pv_list.show()\n    else:\n        self.pv_list.hide()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.PVContextMenu","title":"<code>PVContextMenu</code>","text":"<p>               Bases: <code>QMenu</code></p> <p>Right clicking on the curves table opens 3 options - to open a PV search tool, Open a formula dialogue, or import a csv. Importing a csv seems to have not yet been implemented, but Formulae and PV search are.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>class PVContextMenu(QMenu):\n    \"\"\"Right clicking on the curves table opens 3 options - to open a PV search tool,\n    Open a formula dialogue, or import a csv. Importing a csv seems to have not yet been\n    implemented, but Formulae and PV search are.\"\"\"\n\n    def __init__(self, parent: QObject = None) -&gt; None:\n        super().__init__(parent)\n\n        self._selected_index = None\n        self.archive_search = ArchiveSearchWidget()\n        self._formula_dialog = FormulaDialog(self)\n        # Add \"SEARCH PV\" option\n        search_pv_action = QAction(\"SEARCH PV\", self)\n        search_pv_action.triggered.connect(self.archive_search.show)\n        self.addAction(search_pv_action)\n\n        # Add \"FORMULA\" option\n        formula_action = QAction(\"FORMULA\", self)\n        formula_action.triggered.connect(self._formula_dialog.exec_)\n        self.addAction(formula_action)\n\n        import_action = QAction(\"IMPORT CSV\", self)\n        import_action.triggered.connect(self.import_csv)\n        self.addAction(import_action)\n\n    @property\n    def selected_index(self) -&gt; QModelIndex:\n        \"\"\"Get the table's selected index.\"\"\"\n        return self._selected_index\n\n    @selected_index.setter\n    def selected_index(self, ind: QModelIndex) -&gt; None:\n        \"\"\"Set the table's selected index.\"\"\"\n        self._selected_index = ind\n\n    @Slot()\n    def import_csv(self) -&gt; None:\n        # TODO: Add action to import csv\n        pass\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.PVContextMenu.selected_index","title":"<code>selected_index: QModelIndex</code>  <code>property</code> <code>writable</code>","text":"<p>Get the table's selected index.</p>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin","title":"<code>TracesTableMixin</code>","text":"<p>Mixins class for the Traces tab of the settings section.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>class TracesTableMixin:\n    \"\"\"Mixins class for the Traces tab of the settings section.\"\"\"\n\n    def traces_table_init(self) -&gt; None:\n        \"\"\"Initialize the Traces table model and section.\"\"\"\n        self.curves_model = ArchiverCurveModel(self, self.ui.main_plot, self.axis_table_model)\n        self.ui.traces_tbl.setModel(self.curves_model)\n\n        self.menu = PVContextMenu(self)\n        self.ui.traces_tbl.customContextMenuRequested.connect(self.custom_context_menu)\n\n        self.hdr = self.ui.traces_tbl.horizontalHeader()\n        self.hdr.setSectionResizeMode(QHeaderView.Stretch)\n        channel_col = self.curves_model.getColumnIndex(\"Channel\")\n        self.hdr.setSectionResizeMode(channel_col, QHeaderView.ResizeToContents)\n        del_col = self.curves_model.getColumnIndex(\"\")\n        self.hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n        self.setAcceptDrops(True)\n        self.menu.archive_search.append_PVs_requested.connect(self.insertPVs)\n        self.curves_model.multiplePVInsert.connect(self.insertPVs)\n\n    def curve_delegates_init(self) -&gt; None:\n        \"\"\"Set column delegates for the Traces table to display widgets.\"\"\"\n        axis_col = self.curves_model.getColumnIndex(\"Y-Axis Name\")\n        axis_combo_del = ComboBoxDelegate(self.ui.traces_tbl, self.axis_table_model)\n        self.ui.traces_tbl.setItemDelegateForColumn(axis_col, axis_combo_del)\n\n        color_col = self.curves_model.getColumnIndex(\"Color\")\n        color_button_del = ColorButtonDelegate(self.ui.traces_tbl)\n        self.ui.traces_tbl.setItemDelegateForColumn(color_col, color_button_del)\n\n        style_col = self.curves_model.getColumnIndex(\"Style\")\n        style_combo_del = ComboBoxDelegate(self.ui.traces_tbl, {\"Direct\": None, \"Step\": \"right\"})\n        self.ui.traces_tbl.setItemDelegateForColumn(style_col, style_combo_del)\n\n        styles = BasePlotCurveItem.lines\n        line_style_col = self.curves_model.getColumnIndex(\"Line Style\")\n        line_style_del = ComboBoxDelegate(self.ui.traces_tbl, styles)\n        self.ui.traces_tbl.setItemDelegateForColumn(line_style_col, line_style_del)\n\n        size_data = {f\"{i}px\": i for i in range(1, 6)}\n        line_width_col = self.curves_model.getColumnIndex(\"Line Width\")\n        line_width_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n        self.ui.traces_tbl.setItemDelegateForColumn(line_width_col, line_width_del)\n\n        symbols = BasePlotCurveItem.symbols\n        symbol_col = self.curves_model.getColumnIndex(\"Symbol\")\n        symbol_del = ComboBoxDelegate(self.ui.traces_tbl, symbols)\n        self.ui.traces_tbl.setItemDelegateForColumn(symbol_col, symbol_del)\n\n        size_data = {f\"{i}px\": i for i in range(5, 26, 5)}\n        symbol_size_col = self.curves_model.getColumnIndex(\"Symbol Size\")\n        symbol_size_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n        self.ui.traces_tbl.setItemDelegateForColumn(symbol_size_col, symbol_size_del)\n\n        delete_col = self.curves_model.getColumnIndex(\"\")\n        delete_row_del = DeleteRowDelegate(self.ui.traces_tbl)\n        self.ui.traces_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n\n    def dragEnterEvent(self, e: QDragEnterEvent) -&gt; None:\n        \"\"\"Handle something (like PV names) being dragged into the table\"\"\"\n        e.acceptProposedAction()\n\n    def dragMoveEvent(self, e: QDragMoveEvent) -&gt; None:\n        \"\"\"Handle something (like PV names) being dragged through the table\"\"\"\n        e.acceptProposedAction()\n\n    def dropEvent(self, e: QDropEvent) -&gt; None:\n        \"\"\"Handle something (like PV names) being dropped into the table\"\"\"\n        data = e.mimeData().text()\n        self.insertPVs(data)\n\n    def insertPVs(self, data: str) -&gt; None:\n        \"\"\"Parse the incoming PV name data\n        One by one, add them to the end of the curves model\n        Resize the table to match the longest PV name/label\n\n        Parameters\n        ---------------\n        data: str\n            The list of pvs in string format with any white space or comma separation\"\"\"\n        logger.info(\"Accepting PVs \" + data)\n        channels = re.split(r\"[\\s,]+\", data)\n        for channel in channels:\n            index = -1\n            curve = self.curves_model.curve_at_index(index)\n            self.curves_model.set_data(column_name=\"Channel\", curve=curve, value=channel)\n        self.ui.traces_tbl.update()\n        self.hdr.setSectionResizeMode(self.curves_model.getColumnIndex(\"Channel\"), QHeaderView.ResizeToContents)\n        self.hdr.setSectionResizeMode(self.curves_model.getColumnIndex(\"Label\"), QHeaderView.ResizeToContents)\n\n    @Slot(QPoint)\n    def custom_context_menu(self, pos: QPoint) -&gt; None:\n        \"\"\"Open a custom context menu for the Traces table where the\n        user right-clicks. If the ColorButton is right-clicked, then do\n        not open a context menu.\n\n        Parameters\n        ----------\n        pos : QPoint\n            The position where the context menu should appear\n        \"\"\"\n        table = self.ui.traces_tbl\n        if not table or not isinstance(table, QTableView):\n            logger.error(f\"Internal error: {type(table)} is not QTableView\")\n            return\n\n        index = table.indexAt(pos)\n        is_color = index.column() == self.curves_model.getColumnIndex(\"Color\")\n        logger.debug(f\"ColorButton column selected: {is_color}\")\n\n        if index.isValid() and not is_color:\n            logger.debug(f\"Opening context menu at index {index}\")\n            self.menu.selected_index = index\n            self.menu.popup(table.viewport().mapToGlobal(pos))\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.curve_delegates_init","title":"<code>curve_delegates_init()</code>","text":"<p>Set column delegates for the Traces table to display widgets.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def curve_delegates_init(self) -&gt; None:\n    \"\"\"Set column delegates for the Traces table to display widgets.\"\"\"\n    axis_col = self.curves_model.getColumnIndex(\"Y-Axis Name\")\n    axis_combo_del = ComboBoxDelegate(self.ui.traces_tbl, self.axis_table_model)\n    self.ui.traces_tbl.setItemDelegateForColumn(axis_col, axis_combo_del)\n\n    color_col = self.curves_model.getColumnIndex(\"Color\")\n    color_button_del = ColorButtonDelegate(self.ui.traces_tbl)\n    self.ui.traces_tbl.setItemDelegateForColumn(color_col, color_button_del)\n\n    style_col = self.curves_model.getColumnIndex(\"Style\")\n    style_combo_del = ComboBoxDelegate(self.ui.traces_tbl, {\"Direct\": None, \"Step\": \"right\"})\n    self.ui.traces_tbl.setItemDelegateForColumn(style_col, style_combo_del)\n\n    styles = BasePlotCurveItem.lines\n    line_style_col = self.curves_model.getColumnIndex(\"Line Style\")\n    line_style_del = ComboBoxDelegate(self.ui.traces_tbl, styles)\n    self.ui.traces_tbl.setItemDelegateForColumn(line_style_col, line_style_del)\n\n    size_data = {f\"{i}px\": i for i in range(1, 6)}\n    line_width_col = self.curves_model.getColumnIndex(\"Line Width\")\n    line_width_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n    self.ui.traces_tbl.setItemDelegateForColumn(line_width_col, line_width_del)\n\n    symbols = BasePlotCurveItem.symbols\n    symbol_col = self.curves_model.getColumnIndex(\"Symbol\")\n    symbol_del = ComboBoxDelegate(self.ui.traces_tbl, symbols)\n    self.ui.traces_tbl.setItemDelegateForColumn(symbol_col, symbol_del)\n\n    size_data = {f\"{i}px\": i for i in range(5, 26, 5)}\n    symbol_size_col = self.curves_model.getColumnIndex(\"Symbol Size\")\n    symbol_size_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n    self.ui.traces_tbl.setItemDelegateForColumn(symbol_size_col, symbol_size_del)\n\n    delete_col = self.curves_model.getColumnIndex(\"\")\n    delete_row_del = DeleteRowDelegate(self.ui.traces_tbl)\n    self.ui.traces_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.custom_context_menu","title":"<code>custom_context_menu(pos)</code>","text":"<p>Open a custom context menu for the Traces table where the user right-clicks. If the ColorButton is right-clicked, then do not open a context menu.</p>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.custom_context_menu--parameters","title":"Parameters","text":"<p>pos : QPoint     The position where the context menu should appear</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>@Slot(QPoint)\ndef custom_context_menu(self, pos: QPoint) -&gt; None:\n    \"\"\"Open a custom context menu for the Traces table where the\n    user right-clicks. If the ColorButton is right-clicked, then do\n    not open a context menu.\n\n    Parameters\n    ----------\n    pos : QPoint\n        The position where the context menu should appear\n    \"\"\"\n    table = self.ui.traces_tbl\n    if not table or not isinstance(table, QTableView):\n        logger.error(f\"Internal error: {type(table)} is not QTableView\")\n        return\n\n    index = table.indexAt(pos)\n    is_color = index.column() == self.curves_model.getColumnIndex(\"Color\")\n    logger.debug(f\"ColorButton column selected: {is_color}\")\n\n    if index.isValid() and not is_color:\n        logger.debug(f\"Opening context menu at index {index}\")\n        self.menu.selected_index = index\n        self.menu.popup(table.viewport().mapToGlobal(pos))\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.dragEnterEvent","title":"<code>dragEnterEvent(e)</code>","text":"<p>Handle something (like PV names) being dragged into the table</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def dragEnterEvent(self, e: QDragEnterEvent) -&gt; None:\n    \"\"\"Handle something (like PV names) being dragged into the table\"\"\"\n    e.acceptProposedAction()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.dragMoveEvent","title":"<code>dragMoveEvent(e)</code>","text":"<p>Handle something (like PV names) being dragged through the table</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def dragMoveEvent(self, e: QDragMoveEvent) -&gt; None:\n    \"\"\"Handle something (like PV names) being dragged through the table\"\"\"\n    e.acceptProposedAction()\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.dropEvent","title":"<code>dropEvent(e)</code>","text":"<p>Handle something (like PV names) being dropped into the table</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def dropEvent(self, e: QDropEvent) -&gt; None:\n    \"\"\"Handle something (like PV names) being dropped into the table\"\"\"\n    data = e.mimeData().text()\n    self.insertPVs(data)\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.insertPVs","title":"<code>insertPVs(data)</code>","text":"<p>Parse the incoming PV name data One by one, add them to the end of the curves model Resize the table to match the longest PV name/label</p>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.insertPVs--parameters","title":"Parameters","text":"<p>data: str     The list of pvs in string format with any white space or comma separation</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def insertPVs(self, data: str) -&gt; None:\n    \"\"\"Parse the incoming PV name data\n    One by one, add them to the end of the curves model\n    Resize the table to match the longest PV name/label\n\n    Parameters\n    ---------------\n    data: str\n        The list of pvs in string format with any white space or comma separation\"\"\"\n    logger.info(\"Accepting PVs \" + data)\n    channels = re.split(r\"[\\s,]+\", data)\n    for channel in channels:\n        index = -1\n        curve = self.curves_model.curve_at_index(index)\n        self.curves_model.set_data(column_name=\"Channel\", curve=curve, value=channel)\n    self.ui.traces_tbl.update()\n    self.hdr.setSectionResizeMode(self.curves_model.getColumnIndex(\"Channel\"), QHeaderView.ResizeToContents)\n    self.hdr.setSectionResizeMode(self.curves_model.getColumnIndex(\"Label\"), QHeaderView.ResizeToContents)\n</code></pre>"},{"location":"api_reference/traces_table/#mixins.traces_table.TracesTableMixin.traces_table_init","title":"<code>traces_table_init()</code>","text":"<p>Initialize the Traces table model and section.</p> Source code in <code>trace/mixins/traces_table.py</code> <pre><code>def traces_table_init(self) -&gt; None:\n    \"\"\"Initialize the Traces table model and section.\"\"\"\n    self.curves_model = ArchiverCurveModel(self, self.ui.main_plot, self.axis_table_model)\n    self.ui.traces_tbl.setModel(self.curves_model)\n\n    self.menu = PVContextMenu(self)\n    self.ui.traces_tbl.customContextMenuRequested.connect(self.custom_context_menu)\n\n    self.hdr = self.ui.traces_tbl.horizontalHeader()\n    self.hdr.setSectionResizeMode(QHeaderView.Stretch)\n    channel_col = self.curves_model.getColumnIndex(\"Channel\")\n    self.hdr.setSectionResizeMode(channel_col, QHeaderView.ResizeToContents)\n    del_col = self.curves_model.getColumnIndex(\"\")\n    self.hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n    self.setAcceptDrops(True)\n    self.menu.archive_search.append_PVs_requested.connect(self.insertPVs)\n    self.curves_model.multiplePVInsert.connect(self.insertPVs)\n</code></pre>"},{"location":"how_to/axes/","title":"Axes","text":"<p>The Axes tab of the properties section is where users will be able to manage the axes on their plot. From adding/removing axes, hiding axes, or changing an axis' properties, users have plenty of control over the Y-Axes of their plot.</p> <p>While most X-Axis (timerange) controls should be conducted through the mouse, users can set their time range in the Axes tab as well. This can be done with the 2 datetime widgets at the top of the tab. They can be used to set an absolute date and time for either side of the X-Axis.</p> <p>Users can control which Y-Axis each curve is attached to from the Traces tab. More information here.</p>"},{"location":"how_to/axes/#adding-axes","title":"Adding Axes","text":"<p>Y-Axes should be added automatically, but users can add more as needed using the \"Add Axis\" button at the bottom of the section. By default, new axes will have these properties: - Named \"Axis #\" (where <code>#</code> is an incrementing number) - Oriented to the left - Auto Range enabled - Log Mode disabled - Not Hidden</p>"},{"location":"how_to/axes/#deleting-axes","title":"Deleting Axes","text":"<p>Users can remove axes by clicking the \"Delete Row\" button for the given axis in the rightmost column. Deleting an axis will remove the axis from both the table and the plot, as well as all of the traces attached to that axis.</p>"},{"location":"how_to/axes/#hiding-axes","title":"Hiding Axes","text":"<p>Users have the option to hide/show Y-Axes on the plot using the checkbox in the second to last column. By hiding a Y-Axis, all curves attached to that axis will be hidden as well.</p>"},{"location":"how_to/file_conversion/","title":"CLI File Converter Tool","text":"<p>Included in this application is a tool for converting files from the Archive Viewer's format into Trace's format. The tool can be found at <code>trace/trace_file_converter.py</code> and can be called directly from the command-line. This allows users to convert their files without having to open Trace.</p>"},{"location":"how_to/file_conversion/#usage","title":"Usage","text":"<p><code>trace_file_convert.py [-h] [--output_file OUTPUT_FILE] [--overwrite] [--clean] input_file</code></p> <p>The file converter tool takes in a few optional arguments to give the user more control over how they use it.</p>"},{"location":"how_to/file_conversion/#positional-arguments","title":"Positional Arguments","text":""},{"location":"how_to/file_conversion/#input-file","title":"Input File","text":"<p>The only positional argument is the file to be converted, labeled <code>input_file</code>. This should be provided as a path to the file, either relative or absolute. The conversion will fail if the file does not exist or does not use the <code>.xml</code> file extension or if it's incorrectly formatted.</p> <p>Example: <code>python trace_file_convert.py examples/FormulaExample.trc</code></p>"},{"location":"how_to/file_conversion/#optional-arguments","title":"Optional Arguments","text":""},{"location":"how_to/file_conversion/#output-file-o-output_file","title":"Output File: -o, --output_file","text":"<p>Users can use this argument to pass the name and path the converted file should be saved as. If not provided, the new file will be the same as the input file. A file extension does not need to be provided in the new name. The conversion fails if the provided output file name has a file extension and it is not <code>.trc</code>.</p> <p>Example: <code>python trace_file_convert.py examples/FormulaExample.trc -o some_file.trc</code></p>"},{"location":"how_to/file_conversion/#overwrite-w-overwrite","title":"Overwrite: -w, --overwrite","text":"<p>The conversion will fail if a file already exists with the new file name (provided or default). Using the overwrite flag ignores the interrupt, allowing the tool to replace the existing file with the new file.</p> <p>Example: <code>python trace_file_convert.py examples/FormulaExample.trc -o some_file.trc -w</code></p>"},{"location":"how_to/file_conversion/#clean-clean","title":"Clean: --clean","text":"<p>This flag results in the conversion tool removing the input file after the conversion has been made.</p> <p>Example: <code>python trace_file_convert.py examples/FormulaExample.trc --clean</code></p>"},{"location":"how_to/io/","title":"Import and Export","text":"<p>Trace allows users to export their current configuration of the application into a save file so that it can be imported later. The exported files include the archiver URL used, plot's configuration, the X-axis' time range, all of the Y-axes, and all of the traces.</p> <p>The importing and exporting features can be found in the menu bar at the top of the application under the Action menu. Alternatively, users can export their current configuration with <code>Ctrl+S</code> or import a file with <code>Ctrl+L</code>.</p> <p>Files can also be imported on startup using the <code>-i</code> flag followed by the path to the file. Find more information on application arguments here.</p>"},{"location":"how_to/io/#save-files","title":"Save Files","text":"<p>Trace's save files are in JSON format as to be human readable/writeable and they use their own file extension: <code>.trc</code>.</p>"},{"location":"how_to/io/#java-save-files","title":"Java Save Files","text":"<p>Save files for the Java-based Archive Viewer can also be imported into Trace. They are hidden in the file explorer by default. To show them, click the dropdown at the bottom of the file explorer dialog labeled <code>Files of type:</code> and select the option for <code>Java Archive Viewer (*.xml)</code>. Now you should be see only directories and <code>.xml</code> files.</p> <p>Trace will not save new files in the Java-based Archive Viewer's format, only as <code>.trc</code> files.</p> <p>Files can be converted en masse from the Java-based file format to Trace's formate using the CLI file converter tool.</p>"},{"location":"how_to/io/#note-about-colors","title":"Note About Colors","text":"<p>Colors in the save file will typically be represented as RGB values in hexidecimal format. Since the string will be passed into a QColor when loaded, these strings can be names of colors as well e.g. \"red\", \"blue\", \"white\", etc.</p>"},{"location":"how_to/overview/","title":"Overview","text":"<p>Trace is a PyDM application used to plot value data for given PVs. The application is capable of plotting both live and archived data, as well as formulas containing PVs as variables.</p> <p>The top of the application shows a few buttons for quickly toggling between common time spans (30s, 1m, 1h, 1w, 1M). Below that the application is split into two main parts: - Plot section - Properties section</p> <p>Users are able to control the size of these two sections by clicking and dragging the horizontal gray splitter in the center of the application. The properties section can be completely collapsed so that the application only shows the plot.</p>"},{"location":"how_to/overview/#plot-section-mouse-interaction","title":"Plot Section &amp; Mouse Interaction","text":"<p>The plot section shows the plot. It displays whatever traces, axes, or other properties the user sets on it.</p> <p>The plot's axes can be controlled using the mouse. Users can scroll up to zoom in, or scroll down to zoom out. If this is done over a single axis, then just the one axis is affected. However, if the user scrolls in the plotting area, then the X-Axis and all Y-Axes will zoom in the corresponding direction.</p> <p>Users are able to pan along a single axis by clicking and dragging it. This works on both X and Y-Axes. Clicking and dragging in the plotting area has a different functionality. A box will be drawn between where the mouse button was pressed and where it was released, and then the plot will zoom in to show the selected range.</p>"},{"location":"how_to/overview/#properties-section","title":"Properties Section","text":"<p>The properties section is split into 3 different tabs: - Traces - Axes - Plot</p> <p>Each of these tabs allow the user to set the properties for the given topic. More details can be found in their respective how to article.</p>"},{"location":"how_to/overview/#footer","title":"Footer","text":"<p>At the very bottom of the screen is a footer containing some information that may be useful to users. There is also a logger displayed at the bottom, which can show what actions are being performed.</p> <p>The left side displays (left to right) the application's: - Current release tag - Node running it - User running it - PID - Archiver URL being used to fetch archiver data</p> <p>The right side displays the current date and time, which can be useful when reviewing screenshots.</p>"},{"location":"how_to/plot_config/","title":"Configuring the Plot","text":"<p>The Plot configuration tab is where users get to customize the look of their plot. Plot configuration will be included in the Trace save files, meaning that the customizations can be imported by the user. Customizing the plot can be useful when taking a screenshot of the plot to share.</p> <p>Below is a brief description of each of the properties that can be customized.</p>"},{"location":"how_to/plot_config/#plot-title","title":"Plot Title","text":"<p>Allows the user to set the title of their plot to whatever text they want. By default, the plot has no title.</p>"},{"location":"how_to/plot_config/#grid-lines","title":"Grid Lines","text":"<p>Show/hide horizontal and/or vertical grid lines. Both are off by default.</p>"},{"location":"how_to/plot_config/#legend","title":"Legend","text":"<p>Show or hide the plot's legend. The legend will show a list of all traces' labels on the plot and their associated color. There is no customization for the legend yet. The legend is hidden by default.</p>"},{"location":"how_to/plot_config/#font-size","title":"Font Size","text":"<p>Control the size of the font on the X-Axis. Shrinking the font will show labels for more tick marks, and increasing it will show fewer. The size can be set within the range [1, 99], and defaults to 12.</p>"},{"location":"how_to/plot_config/#autoscroll-refresh-rate","title":"Autoscroll Refresh Rate","text":"<p>Controls how long the autoscroll feature will wait before shifting the plot's timerange to the right. Default is 5 seconds.</p>"},{"location":"how_to/plot_config/#background-color","title":"Background Color","text":"<p>Allows the user to set the plot's background color. Default is white.</p>"},{"location":"how_to/plot_config/#mouse-mode","title":"Mouse Mode","text":"<p>Users can choose to change the plot's mouse mode when clicking and dragging. The options are Rect (default) or Pan. Rect draws a rectangle between where the mouse is pressed and released, and zooms to show that rectangle. Pan will pan the X and Y axes whichever way the user moves the mouse.</p>"},{"location":"how_to/plot_config/#opacity","title":"Opacity","text":"<p>Controls the opacity of the plot's grid lines. Defaults to about 50%.</p>"},{"location":"how_to/plot_config/#crosshair","title":"Crosshair","text":"<p>Shows a yellow crosshair where the user is mousing over the plot. Disabled by default.</p>"},{"location":"how_to/traces/","title":"Traces","text":"<p>Traces, sometimes called curves, are the lines that are shown on the application's plot. They show both live and archive data for the given channel.</p> <p>The properties of each trace can be controlled by the user in the application's traces table, which can be found by navigating to the properties section of the app and selecting the tab labeled \"Traces\". This tab will be shown by default.</p>"},{"location":"how_to/traces/#formula-traces","title":"Formula Traces","text":"<p>Users can add formulas to the plot by entering their formula to be calculated as the trace's channel. The formula should be prepended with \"f://\" to signify that the channel is a formula. Formulas can also be added using the formula input tool.</p> <p>Other traces the formula uses are represented by their unique row header in a set of curly brackets, e.g. {A}, {X}, {AV}. Formulas can include all basic arithmetic and binary operations, as well as <code>mean</code> and all functions in Python's standard math library.</p> <p>As an example, if we have some 2 PVs with the row headers A and B, then we may have the formula <code>f://{A} + {B}</code> or maybe <code>f://min({A}, {B})</code> or <code>f://{A} ^ {B}</code>.</p>"},{"location":"how_to/traces/#adding-traces","title":"Adding Traces","text":"<p>Users can add traces to the plot by including them in the traces table. This can be done by entering a channel into the last row, which should always be empty. Once a channel is included, the trace should be added to the plot and both live and archived data will be shown. Traces can also be added using the PV Search tool</p> <p>In addition, users can paste multiple PVs at once into the table in one row's channel box, and it will append them as separate PVs, as long as their names are separated by commas or white space.</p> <p>When adding new traces, they will be attached to a y-axis with the same unit. If no such axis exists, a new one will be created for the channel's unit. If the channel has no units, a new axis will be created with no associated units.</p>"},{"location":"how_to/traces/#removing-traces","title":"Removing Traces","text":"<p>Traces can be removed by the user by clicking the \"Delete Row\" button for the given trace entry in the rightmost column. This will remove the row from the table and remove the trace from the plot in one swift motion.</p>"},{"location":"how_to/traces/#trace-properties","title":"Trace Properties","text":""},{"location":"how_to/traces/#channel","title":"Channel","text":"<p>Setting a trace's channel is necessary for the trace to exist. This is the data source that the trace will represent. This is also the section where a user can add a formula. More details can be found above.</p>"},{"location":"how_to/traces/#live-data-archive-data","title":"Live Data &amp; Archive Data","text":"<p>The user can determine what kind of data should be fetched. Live data will be added to the trace on the channel's value change. If Live data fetching is disabled and then later reenabled, then archiver data will be fetched to backfill the missing section. By default, both Live data and Archive data fetching are enabled.</p>"},{"location":"how_to/traces/#label","title":"Label","text":"<p>The string the curve should be represented as on the axes and in the legend. Defaults to the channel name.</p>"},{"location":"how_to/traces/#color","title":"Color","text":"<p>The color the curve should show up as on the plot. Sets the color for the trace and its symbols. Clicking this button will open the default PyQT color selector dialog window. Once the color has been changed, right clicking the button will set it back to its initial color.</p>"},{"location":"how_to/traces/#y-axis-name","title":"Y-Axis Name","text":"<p>A dropdown menu of all of the y-axes on the plot. This allows the user to determine which axis the trace should be attached to. Defaults to y-axis containing curves with the same unit if one exists. If there is no such y-axis, then a new axis will be created.</p>"},{"location":"how_to/traces/#style","title":"Style","text":"<p>A dropdown menu containing 2 options: Direct and Step. The direct style draws sloped lines directly between points on the plot. The step style draws the trace as horizontal lines to the right of their points and continue until a new point on the plot.</p>"},{"location":"how_to/traces/#line-style-line-width","title":"Line Style &amp; Line Width","text":"<p>Controls the style and size of the trace on the plot. The styles include no line, solid (-----), dash (- - -), dot (...), dash dot (-.-.-), and dash dot dot (-..-..). The widths are limited to 1px - 5px, with 1px being the default.</p>"},{"location":"how_to/traces/#symbol-symbol-size","title":"Symbol &amp; Symbol Size","text":"<p>Controls what symbols should be shown at each point on the trace. By default no symbols are shown, but users have many shapes they can choose from including circles, triangles, squares, etc. Users can also choose the size of the symbol at 5px, 10px, 15px, or 20px with 10px being the default.</p>"},{"location":"how_to/traces/#hidden","title":"Hidden","text":"<p>Users can choose if they want individual traces to be shown/hidden on the plot. If all of the curves for a given axis are hidden, then the axis will be hidden as well.</p>"},{"location":"how_to/traces_table_menu/","title":"Context Menu","text":"<p>Right clicking anywhere on the table (except for the color selector button) will open up the table's menu. This menu has 3 options: Search PV, Formula, and Import CSV.</p>"},{"location":"how_to/traces_table_menu/#search-pv","title":"Search PV","text":"<p>Opens a PV search tool which can help you find your PVs easier.</p> <p>When searching, you can find similar PVs by using \"%\", \".\", \"*\", or \"?\" as 'wildcard' characters. That means a search of <code>KLYS:LI22:\\*1:KVAC</code> will find all PVs that have that channel, with any character in the \"*\" slot.</p> <p>Use ctrl + click to toggle separate PVs as selected or not, and shift + click will select a range of PVs. Click the \"Add PVs\" button to append them to the traces table, or drag/drop them anywhere into the viewer. Double clicking a PV will also add that PV.</p>"},{"location":"how_to/traces_table_menu/#formula","title":"Formula","text":"<p>Opens a formula input box to type or click buttons to create a custom formula trace using any number of the existing curves already in the table. This is for ease of use, as you could also type \"f://\" followed by your formula to enter enter it as a trace.</p>"},{"location":"how_to/traces_table_menu/#import-csv","title":"Import CSV","text":"<p>This is a work in progress, but currently does nothing.</p>"}]}