{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Archive Viewer","text":"<p>The Archive Viewer is a python application </p>"},{"location":"archive_viewer/","title":"Archive Viewer","text":""},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer","title":"<code>ArchiveViewer</code>","text":"<p>               Bases: <code>Display</code>, <code>TracesTableMixin</code>, <code>AxisTableMixin</code>, <code>FileIOMixin</code>, <code>PlotConfigMixin</code></p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>class ArchiveViewer(Display, TracesTableMixin, AxisTableMixin, FileIOMixin, PlotConfigMixin):\n    def __init__(self, parent=None, args=None, macros=None, ui_filename=__file__.replace(\".py\", \".ui\")) -&gt; None:\n        super(ArchiveViewer, self).__init__(parent=parent, args=args, macros=macros, ui_filename=ui_filename)\n        # Set up PyDMApplication\n        self.configure_app()\n        self.set_footer()\n\n        # Initialize the Mixins\n        self.axis_table_init()\n        self.traces_table_init()\n        self.plot_config_init()\n        self.file_io_init()\n\n        self.curve_delegates_init()\n        self.axis_delegates_init()\n        self.timespan = -1\n        self.axis_table_model.reset_everything.connect(self.resetPlot)\n        # Create reference dict for timespan_btns button group\n        self.button_spans = {\n            self.ui.half_min_scale_btn: 30,\n            self.ui.min_scale_btn: 60,\n            self.ui.hour_scale_btn: 3600,\n            self.ui.week_scale_btn: 604800,\n            self.ui.month_scale_btn: 2628300,\n            self.ui.cursor_scale_btn: -1\n        }\n        self.ui.timespan_btns.buttonClicked.connect(self.set_plot_timerange)\n\n        # Click \"Cursor\" button on plot-mouse interaction\n        plot_viewbox = self.ui.archiver_plot.plotItem.vb\n        plot_viewbox.sigRangeChangedManually.connect(self.ui.cursor_scale_btn.click)\n\n        # Parse macros &amp; arguments, then include them in startup\n        input_file, startup_pvs = self.parse_macros_and_args(macros, args)\n        if input_file:\n            self.import_save_file(input_file)\n        for pv in startup_pvs:\n            if pv in self.curves_model:\n                continue\n            last_row = self.curves_model.rowCount() - 1\n            index = self.curves_model.index(last_row, 0)\n            self.curves_model.setData(index, pv, Qt.EditRole)\n\n    def menu_items(self) -&gt; dict:\n        \"\"\"Add export &amp; import functionality to File menu\"\"\"\n        return {\"Export\": (self.export_save_file, \"Ctrl+S\"),\n                \"Import\": (self.import_save_file, \"Ctrl+L\")}\n\n    def configure_app(self):\n        \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n        app = QApplication.instance()\n\n        # Hide navigation bar by default (can be shown in menu bar)\n        app.main_window.toggle_nav_bar(False)\n        app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n        # Hide status bar by default (can be shown in menu bar)\n        app.main_window.toggle_status_bar(False)\n        app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n        # Add style to center checkboxes in table cells\n        app.setStyle(CenterCheckStyle())\n\n        # Adjust settings for main_spltr\n        self.ui.main_spltr.setCollapsible(0, False)\n        self.ui.main_spltr.setStretchFactor(0, 1)\n\n    def set_footer(self):\n        \"\"\"Set footer information for application. Includes logging, nodename,\n        username, PID, git version, Archiver URL, and current datetime\n        \"\"\"\n        self.logging_handler = LoggingHandler(self.ui.ftr_logging_lbl)\n        logger.addHandler(self.logging_handler)\n        logger.setLevel(\"NOTSET\")\n\n        self.ui.ftr_node_lbl.setText(os.uname().nodename)\n        self.ui.ftr_user_lbl.setText(os.getlogin())\n        self.ui.ftr_pid_lbl.setText(str(os.getpid()))\n        self.ui.ftr_ver_lbl.setText(self.git_version())\n        self.ui.ftr_url_lbl.setText(os.getenv('PYDM_ARCHIVER_URL'))\n        self.ui.ftr_time_lbl.channel = \"ca://\" + datetime_pv\n\n    @Slot(QAbstractButton)\n    def set_plot_timerange(self, button: QAbstractButton) -&gt; None:\n        \"\"\"Slot to be called when a timespan setting button is pressed.\n        This will enable autoscrolling along the x-axis and disable mouse\n        controls. If the \"Cursor\" button is pressed, then autoscrolling is\n        disabled and mouse controls are enabled.\n\n        Parameters\n        ----------\n        button : QAbstractButton\n            The timespan setting button pressed. Determines which timespan\n            to set.\n        \"\"\"\n        logger.debug(f\"Setting plot timerange\")\n        if button not in self.button_spans:\n            logger.error(f\"{button} is not a valid timespan button\")\n            return\n        enable_scroll = button != self.ui.cursor_scale_btn\n        self.timespan = self.button_spans[button]\n        if enable_scroll:\n            logger.debug(f\"Enabling plot autoscroll for {self.timespan}s\")\n        else:\n            logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n        self.autoScroll(enable=enable_scroll)\n    def parse_macros_and_args(self, macros: Dict[str, str | list], args: List[str]) -&gt; Tuple[str, list]:\n        \"\"\"Parse user provided macros and args into lists of PVs to use on\n        startup or which file to import on startup\n\n        Parameters\n        ----------\n        macros : Dict[str, str | list]\n            Dictionary containing all of the macros passed into PyDM\n        args : List[str]\n            List of all arguments passed into the application to be parsed\n\n        Returns\n        -------\n        tuple\n            A tuple containing the file to import from and the list of PVs to use on startup\n        \"\"\"\n        # Default macros is None\n        if not macros:\n            macros = {}\n\n        # Construct an argument parser for args\n        trace_parser = argparse.ArgumentParser(description=\"Trace\\nThis is a PyDM application \"\n                                               + \"used to display archived and live pv data.\",\n                                               formatter_class=argparse.RawTextHelpFormatter)\n        trace_parser.add_argument(\"-i\", \"--input_file\",\n                                  action=PathAction,\n                                  type=str,\n                                  default=\"\",\n                                  help=\"Absolute file path to import from;\\n\"\n                                  + \"Alternatively can be provided as INPUT_FILE macro\")\n        trace_parser.add_argument(\"-p\", \"--pvs\",\n                                  type=str,\n                                  nargs='*',\n                                  default=[],\n                                  help=\"List of PVs to show on startup;\\n\"\n                                       + \"Alternatively can be provided as PV or PVS macros\")\n\n        # Parse arguments and ignore unknowns\n        trace_args, unknown = trace_parser.parse_known_args(args)\n        if unknown:\n            logger.warning(f\"Not using unknown arguments: {unknown}\")\n\n        # Get the file to import from if one is provided. Prioritize args over macro\n        input_file = trace_args.input_file\n        if not input_file and 'INPUT_FILE' in macros:\n            input_file = macros['INPUT_FILE']\n\n        # Get the list of PVs to show on startup\n        startup_pvs = []\n        for key in (\"PV\", \"PVS\"):\n            if key in macros:\n                val = macros[key]\n                if isinstance(val, str):\n                    startup_pvs.append(val)\n                elif isinstance(val, list):\n                    startup_pvs += val\n        startup_pvs += trace_args.pvs\n\n        # Remove duplicates from startup_pvs\n        startup_pvs = list(dict.fromkeys(startup_pvs))\n\n        return (input_file, startup_pvs)\n\n    @staticmethod\n    def git_version():\n        \"\"\"Get the current git tag for the project\"\"\"\n        project_directory = __file__.rsplit('/', 1)[0]\n        git_cmd = run(f\"cd {project_directory} &amp;&amp; git describe --tags\",\n                      text=True,\n                      shell=True,\n                      capture_output=True)\n        return git_cmd.stdout.strip()\n\n    @Slot()\n    def resetPlot(self) -&gt; None:\n        \"\"\"Reset the Axis model and the Curve model to empty states\"\"\"\n        self.axis_table_model.set_model_axes()\n        self.curves_model.set_model_curves()\n\n    @Slot(QAbstractButton)\n    def set_plot_timerange(self, button: QAbstractButton) -&gt; None:\n        \"\"\"Slot to be called when a timespan setting button is pressed.\n        This will enable autoscrolling along the x-axis and disable mouse\n        controls. If the \"Cursor\" button is pressed, then autoscrolling is\n        disabled and mouse controls are enabled.\n\n        Parameters\n        ----------\n        button : QAbstractButton\n            The timespan setting button pressed. Determines which timespan\n            to set.\n        \"\"\"\n        logger.debug(f\"Setting plot timerange\")\n        if button not in self.button_spans:\n            logger.error(f\"{button} is not a valid timespan button\")\n            return\n        enable_scroll = button != self.ui.cursor_scale_btn\n        self.timespan = self.button_spans[button]\n        if enable_scroll:\n            logger.debug(f\"Enabling plot autoscroll for {self.timespan}s\")\n        else:\n            logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n        self.autoScroll(enable=enable_scroll)\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.configure_app","title":"<code>configure_app()</code>","text":"<p>UI changes to be made to the PyDMApplication</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>def configure_app(self):\n    \"\"\"UI changes to be made to the PyDMApplication\"\"\"\n    app = QApplication.instance()\n\n    # Hide navigation bar by default (can be shown in menu bar)\n    app.main_window.toggle_nav_bar(False)\n    app.main_window.ui.actionShow_Navigation_Bar.setChecked(False)\n\n    # Hide status bar by default (can be shown in menu bar)\n    app.main_window.toggle_status_bar(False)\n    app.main_window.ui.actionShow_Status_Bar.setChecked(False)\n\n    # Add style to center checkboxes in table cells\n    app.setStyle(CenterCheckStyle())\n\n    # Adjust settings for main_spltr\n    self.ui.main_spltr.setCollapsible(0, False)\n    self.ui.main_spltr.setStretchFactor(0, 1)\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.git_version","title":"<code>git_version()</code>  <code>staticmethod</code>","text":"<p>Get the current git tag for the project</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>@staticmethod\ndef git_version():\n    \"\"\"Get the current git tag for the project\"\"\"\n    project_directory = __file__.rsplit('/', 1)[0]\n    git_cmd = run(f\"cd {project_directory} &amp;&amp; git describe --tags\",\n                  text=True,\n                  shell=True,\n                  capture_output=True)\n    return git_cmd.stdout.strip()\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.menu_items","title":"<code>menu_items()</code>","text":"<p>Add export &amp; import functionality to File menu</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>def menu_items(self) -&gt; dict:\n    \"\"\"Add export &amp; import functionality to File menu\"\"\"\n    return {\"Export\": (self.export_save_file, \"Ctrl+S\"),\n            \"Import\": (self.import_save_file, \"Ctrl+L\")}\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.parse_macros_and_args","title":"<code>parse_macros_and_args(macros, args)</code>","text":"<p>Parse user provided macros and args into lists of PVs to use on startup or which file to import on startup</p>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.parse_macros_and_args--parameters","title":"Parameters","text":"<p>macros : Dict[str, str | list]     Dictionary containing all of the macros passed into PyDM args : List[str]     List of all arguments passed into the application to be parsed</p>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.parse_macros_and_args--returns","title":"Returns","text":"<p>tuple     A tuple containing the file to import from and the list of PVs to use on startup</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>def parse_macros_and_args(self, macros: Dict[str, str | list], args: List[str]) -&gt; Tuple[str, list]:\n    \"\"\"Parse user provided macros and args into lists of PVs to use on\n    startup or which file to import on startup\n\n    Parameters\n    ----------\n    macros : Dict[str, str | list]\n        Dictionary containing all of the macros passed into PyDM\n    args : List[str]\n        List of all arguments passed into the application to be parsed\n\n    Returns\n    -------\n    tuple\n        A tuple containing the file to import from and the list of PVs to use on startup\n    \"\"\"\n    # Default macros is None\n    if not macros:\n        macros = {}\n\n    # Construct an argument parser for args\n    trace_parser = argparse.ArgumentParser(description=\"Trace\\nThis is a PyDM application \"\n                                           + \"used to display archived and live pv data.\",\n                                           formatter_class=argparse.RawTextHelpFormatter)\n    trace_parser.add_argument(\"-i\", \"--input_file\",\n                              action=PathAction,\n                              type=str,\n                              default=\"\",\n                              help=\"Absolute file path to import from;\\n\"\n                              + \"Alternatively can be provided as INPUT_FILE macro\")\n    trace_parser.add_argument(\"-p\", \"--pvs\",\n                              type=str,\n                              nargs='*',\n                              default=[],\n                              help=\"List of PVs to show on startup;\\n\"\n                                   + \"Alternatively can be provided as PV or PVS macros\")\n\n    # Parse arguments and ignore unknowns\n    trace_args, unknown = trace_parser.parse_known_args(args)\n    if unknown:\n        logger.warning(f\"Not using unknown arguments: {unknown}\")\n\n    # Get the file to import from if one is provided. Prioritize args over macro\n    input_file = trace_args.input_file\n    if not input_file and 'INPUT_FILE' in macros:\n        input_file = macros['INPUT_FILE']\n\n    # Get the list of PVs to show on startup\n    startup_pvs = []\n    for key in (\"PV\", \"PVS\"):\n        if key in macros:\n            val = macros[key]\n            if isinstance(val, str):\n                startup_pvs.append(val)\n            elif isinstance(val, list):\n                startup_pvs += val\n    startup_pvs += trace_args.pvs\n\n    # Remove duplicates from startup_pvs\n    startup_pvs = list(dict.fromkeys(startup_pvs))\n\n    return (input_file, startup_pvs)\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.resetPlot","title":"<code>resetPlot()</code>","text":"<p>Reset the Axis model and the Curve model to empty states</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>@Slot()\ndef resetPlot(self) -&gt; None:\n    \"\"\"Reset the Axis model and the Curve model to empty states\"\"\"\n    self.axis_table_model.set_model_axes()\n    self.curves_model.set_model_curves()\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.set_footer","title":"<code>set_footer()</code>","text":"<p>Set footer information for application. Includes logging, nodename, username, PID, git version, Archiver URL, and current datetime</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>def set_footer(self):\n    \"\"\"Set footer information for application. Includes logging, nodename,\n    username, PID, git version, Archiver URL, and current datetime\n    \"\"\"\n    self.logging_handler = LoggingHandler(self.ui.ftr_logging_lbl)\n    logger.addHandler(self.logging_handler)\n    logger.setLevel(\"NOTSET\")\n\n    self.ui.ftr_node_lbl.setText(os.uname().nodename)\n    self.ui.ftr_user_lbl.setText(os.getlogin())\n    self.ui.ftr_pid_lbl.setText(str(os.getpid()))\n    self.ui.ftr_ver_lbl.setText(self.git_version())\n    self.ui.ftr_url_lbl.setText(os.getenv('PYDM_ARCHIVER_URL'))\n    self.ui.ftr_time_lbl.channel = \"ca://\" + datetime_pv\n</code></pre>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.set_plot_timerange","title":"<code>set_plot_timerange(button)</code>","text":"<p>Slot to be called when a timespan setting button is pressed. This will enable autoscrolling along the x-axis and disable mouse controls. If the \"Cursor\" button is pressed, then autoscrolling is disabled and mouse controls are enabled.</p>"},{"location":"archive_viewer/#archive_viewer.archive_viewer.ArchiveViewer.set_plot_timerange--parameters","title":"Parameters","text":"<p>button : QAbstractButton     The timespan setting button pressed. Determines which timespan     to set.</p> Source code in <code>archive_viewer/archive_viewer.py</code> <pre><code>@Slot(QAbstractButton)\ndef set_plot_timerange(self, button: QAbstractButton) -&gt; None:\n    \"\"\"Slot to be called when a timespan setting button is pressed.\n    This will enable autoscrolling along the x-axis and disable mouse\n    controls. If the \"Cursor\" button is pressed, then autoscrolling is\n    disabled and mouse controls are enabled.\n\n    Parameters\n    ----------\n    button : QAbstractButton\n        The timespan setting button pressed. Determines which timespan\n        to set.\n    \"\"\"\n    logger.debug(f\"Setting plot timerange\")\n    if button not in self.button_spans:\n        logger.error(f\"{button} is not a valid timespan button\")\n        return\n    enable_scroll = button != self.ui.cursor_scale_btn\n    self.timespan = self.button_spans[button]\n    if enable_scroll:\n        logger.debug(f\"Enabling plot autoscroll for {self.timespan}s\")\n    else:\n        logger.debug(\"Disabling plot autoscroll, using mouse controls\")\n    self.autoScroll(enable=enable_scroll)\n</code></pre>"},{"location":"installation/","title":"Installing Archive Viewer","text":""},{"location":"traces_table/","title":"Traces Table","text":""},{"location":"traces_table/#archive_viewer.mixins.traces_table.FormulaDialog","title":"<code>FormulaDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Formula Dialog - when a user right clicks on a row in the list of curves, they have the option to input a formula They could opt to type it instead, but this opens a box that is a nicer UI for inputting a formula.</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>class FormulaDialog(QDialog):\n    \"\"\"Formula Dialog - when a user right clicks on a row in the list of curves, they have the option to input a formula\n    They could opt to type it instead, but this opens a box that is a nicer UI for inputting a formula.\"\"\"\n    def __init__(self, parent: QObject) -&gt; None:\n        super().__init__(parent)\n        self.setWindowTitle(\"Formula Input\")\n\n        # Create the layout for the dialog\n        layout = QVBoxLayout(self)\n        # Create the QLineEdit for formula input\n        self.field = QLineEdit(self)\n        self.curveModel = self.parent().parent().curves_model\n        self.pv_list = QTableView(self)\n        # We're going to copy the list of PVs from the curve model. We're also not going to allow the user to make edits to the list of PVs\n        self.pv_list.setModel(self.curveModel)\n        self.pv_list.setEditTriggers(QAbstractItemView.EditTriggers(0))\n        self.pv_list.setMaximumWidth(1000)\n        self.pv_list.setMaximumHeight(1000)\n        header = self.pv_list.horizontalHeader()\n        header.setSectionResizeMode(0, QHeaderView.Stretch)\n        for i in range(1, self.curveModel.columnCount() - 1):\n            # Hide all columns that arent useful, but keep one left over to add a button to\n            self.pv_list.setColumnHidden(i, True)\n        insertButton = InsertPVDelegate(self.pv_list)\n        insertButton.button_clicked.connect(self.field.insert)\n        self.pv_list.setItemDelegateForColumn(self.curveModel.columnCount() - 1, insertButton)\n        layout.addWidget(self.pv_list)\n        layout.addWidget(self.field)\n\n        self.index = self.parent().selected_index\n\n        # Define the list of calculator buttons.\n        # It's a bunch of preset buttons, but users can type other functions under math.\n        buttons = [\"7\",       \"8\",     \"9\",      \"+\",     \"(\",      \")\",\n                   \"4\",       \"5\",     \"6\",      \"-\",    \"^2\", \"sqrt()\",\n                   \"1\",       \"2\",     \"3\",      \"*\",   \"^-1\",  \"ln()\",\n                   \"0\",       \"e\",    \"pi\",      \"/\", \"sin()\", \"asin()\",\n                   \".\",   \"abs()\", \"min()\",      \"^\", \"cos()\", \"acos()\",\n                   \"PV\",  \"Clear\", \"max()\", \"mean()\", \"tan()\", \"atan()\"]\n\n        # Create the calculator buttons and connect them to the input field\n        grid_layout = QGridLayout()\n        for i, button_text in enumerate(buttons):\n            button = QPushButton(button_text, self)\n            row = i // 6\n            col = i % 6\n            grid_layout.addWidget(button, row, col)\n            # Connect the button clicked signal to the appropriate action\n            # PV currently does nothing, this is a remnant\n            # From when we would have the pv_list open in a new window\n            if button_text == \"PV\":\n                self.PVButton = button\n                self.PVButton.setCheckable(True)\n                self.PVButton.setChecked(True)\n                self.PVButton.clicked.connect(self.showPVList)\n            elif button_text == \"Clear\":\n                button.clicked.connect(lambda _: self.field.clear())\n            else:\n                button.clicked.connect(lambda _, text=button_text: self.field.insert(text))\n        layout.addLayout(grid_layout)\n\n        # Add an \"OK\" button to accept the formula and close the dialog\n        ok_button = QPushButton(\"OK\", self)\n        ok_button.clicked.connect(self.accept_formula)\n        layout.addWidget(ok_button)\n        self.showPVList()\n\n    def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n        \"\"\"Special key press tracker, just so that if enter or return is pressed the formula dialog attempts to submit the formula\"\"\"\n        if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n            self.accept_formula()\n        return super().keyPressEvent(e)\n\n    @Slot()\n    def showPVList(self):\n        show = self.PVButton.isChecked()\n        if show:\n            self.pv_list.show()\n        else:\n            self.pv_list.hide()\n\n    def exec_(self):\n        \"\"\" When the formula dialog is opened (every time) we need to\n            update it with the latest information on the curve model and\n            also populate the text box with the pre-existing formula (if it already was there)\"\"\"\n        self.index = self.parent().selected_index\n        self.pv_list.setRowHidden(len(self.curveModel._row_names) - 1, True)\n        for i in range(self.curveModel.rowCount() - 1):\n            self.pv_list.setRowHidden(i, False)\n        index = self.curveModel.index(self.index.row(), 0)\n        curve = self.curveModel._plot._curves[self.index.row()]\n        if index.data() and isinstance(curve, FormulaCurveItem):\n            self.field.setText(str(index.data()).strip(\"f://\"))\n        else:\n            self.field.setText(\"\")\n        super().exec_()\n\n    @Slot()\n    def accept_formula(self) -&gt; None:\n        \"\"\" Retrieve the formula and PV name and perform desired actions\n         We take in the formula (prepend the formula tag) and attempt to create a curve. Iff it passes, we close the window\"\"\"\n        formula = \"f://\" + self.field.text()\n        passed = self.curveModel.replaceToFormula(index = self.curveModel.index(self.parent().selected_index.row(), 0), formula = formula)\n        if passed:\n            self.field.setText(\"\")\n            self.accept()\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.FormulaDialog.accept_formula","title":"<code>accept_formula()</code>","text":"<p>Retrieve the formula and PV name and perform desired actions We take in the formula (prepend the formula tag) and attempt to create a curve. Iff it passes, we close the window</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>@Slot()\ndef accept_formula(self) -&gt; None:\n    \"\"\" Retrieve the formula and PV name and perform desired actions\n     We take in the formula (prepend the formula tag) and attempt to create a curve. Iff it passes, we close the window\"\"\"\n    formula = \"f://\" + self.field.text()\n    passed = self.curveModel.replaceToFormula(index = self.curveModel.index(self.parent().selected_index.row(), 0), formula = formula)\n    if passed:\n        self.field.setText(\"\")\n        self.accept()\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.FormulaDialog.exec_","title":"<code>exec_()</code>","text":"<p>When the formula dialog is opened (every time) we need to update it with the latest information on the curve model and also populate the text box with the pre-existing formula (if it already was there)</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>def exec_(self):\n    \"\"\" When the formula dialog is opened (every time) we need to\n        update it with the latest information on the curve model and\n        also populate the text box with the pre-existing formula (if it already was there)\"\"\"\n    self.index = self.parent().selected_index\n    self.pv_list.setRowHidden(len(self.curveModel._row_names) - 1, True)\n    for i in range(self.curveModel.rowCount() - 1):\n        self.pv_list.setRowHidden(i, False)\n    index = self.curveModel.index(self.index.row(), 0)\n    curve = self.curveModel._plot._curves[self.index.row()]\n    if index.data() and isinstance(curve, FormulaCurveItem):\n        self.field.setText(str(index.data()).strip(\"f://\"))\n    else:\n        self.field.setText(\"\")\n    super().exec_()\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.FormulaDialog.keyPressEvent","title":"<code>keyPressEvent(e)</code>","text":"<p>Special key press tracker, just so that if enter or return is pressed the formula dialog attempts to submit the formula</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>def keyPressEvent(self, e: QKeyEvent) -&gt; None:\n    \"\"\"Special key press tracker, just so that if enter or return is pressed the formula dialog attempts to submit the formula\"\"\"\n    if e.key() == Qt.Key_Return or e.key() == Qt.Key_Enter:\n        self.accept_formula()\n    return super().keyPressEvent(e)\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.PVContextMenu","title":"<code>PVContextMenu</code>","text":"<p>               Bases: <code>QMenu</code></p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>class PVContextMenu(QMenu):\n    # TODO: Change this QMenu so functions that change data stay in table object\n    #   - Move functions to table widget\n    #   - Init parameters: dict(\"ACTION_NAME\": function)\n    #   - Init: Loop through dict values:\n    #       - Create action w/ name\n    #       - action.triggered.connect(function)\n    #       - self.addAction(action)\n\n    # data_changed_signal = Signal(int)\n\n    # TODO: Archived PVs are no longer draggable from the search tool. Find out why\n\n    def __init__(self, parent: QObject = None) -&gt; None:\n        super().__init__(parent)\n        self._selected_index = None\n        self.archive_search = ArchiveSearchWidget()\n        self._formula_dialog = FormulaDialog(self)\n\n        # Add \"SEARCH PV\" option\n        search_pv_action = QAction(\"SEARCH PV\", self)\n        search_pv_action.triggered.connect(self.archive_search.show)\n        self.addAction(search_pv_action)\n\n        # Add \"FORMULA\" option\n        formula_action = QAction(\"FORMULA\", self)\n        formula_action.triggered.connect(self._formula_dialog.exec_)\n        self.addAction(formula_action)\n\n        import_action = QAction(\"IMPORT CSV\", self)\n        import_action.triggered.connect(self.import_csv)\n        self.addAction(import_action)\n\n    @property\n    def selected_index(self) -&gt; QModelIndex:\n        \"\"\"Get the table's selected index.\"\"\"\n        return self._selected_index\n\n    @selected_index.setter\n    def selected_index(self, ind: QModelIndex) -&gt; None:\n        \"\"\"Set the table's selected index.\"\"\"\n        self._selected_index = ind\n\n    @Slot()\n    def import_csv(self) -&gt; None:\n        # TODO: Add action to import csv\n        pass\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.PVContextMenu.selected_index","title":"<code>selected_index: QModelIndex</code>  <code>property</code> <code>writable</code>","text":"<p>Get the table's selected index.</p>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.TracesTableMixin","title":"<code>TracesTableMixin</code>","text":"<p>Mixins class for the Traces tab of the settings section.</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>class TracesTableMixin:\n    \"\"\"Mixins class for the Traces tab of the settings section.\"\"\"\n    def traces_table_init(self) -&gt; None:\n        \"\"\"Initialize the Traces table model and section.\"\"\"\n        self.curves_model = ArchiverCurveModel(self, self.ui.archiver_plot, self.axis_table_model)\n        self.ui.traces_tbl.setModel(self.curves_model)\n\n        self.menu = PVContextMenu(self)\n        self.ui.traces_tbl.customContextMenuRequested.connect(self.custom_context_menu)\n\n        hdr = self.ui.traces_tbl.horizontalHeader()\n        hdr.setSectionResizeMode(QHeaderView.Stretch)\n        channel_col = self.curves_model.getColumnIndex(\"Channel\")\n        hdr.setSectionResizeMode(channel_col, QHeaderView.ResizeToContents)\n        del_col = self.curves_model.getColumnIndex(\"\")\n        hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n\n    def curve_delegates_init(self) -&gt; None:\n        \"\"\"Set column delegates for the Traces table to display widgets.\"\"\"\n        axis_col = self.curves_model.getColumnIndex(\"Y-Axis Name\")\n        axis_combo_del = ComboBoxDelegate(self.ui.traces_tbl, self.axis_table_model)\n        self.ui.traces_tbl.setItemDelegateForColumn(axis_col, axis_combo_del)\n\n        color_col = self.curves_model.getColumnIndex(\"Color\")\n        color_button_del = ColorButtonDelegate(self.ui.traces_tbl)\n        self.ui.traces_tbl.setItemDelegateForColumn(color_col, color_button_del)\n\n        style_col = self.curves_model.getColumnIndex(\"Style\")\n        style_combo_del = ComboBoxDelegate(self.ui.traces_tbl, {\"Direct\": None, \"Step\": \"right\"})\n        self.ui.traces_tbl.setItemDelegateForColumn(style_col, style_combo_del)\n\n        styles = BasePlotCurveItem.lines\n        line_style_col = self.curves_model.getColumnIndex(\"Line Style\")\n        line_style_del = ComboBoxDelegate(self.ui.traces_tbl, styles)\n        self.ui.traces_tbl.setItemDelegateForColumn(line_style_col, line_style_del)\n\n        size_data = {f\"{i}px\": i for i in range(1, 6)}\n        line_width_col = self.curves_model.getColumnIndex(\"Line Width\")\n        line_width_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n        self.ui.traces_tbl.setItemDelegateForColumn(line_width_col, line_width_del)\n\n        symbols = BasePlotCurveItem.symbols\n        symbol_col = self.curves_model.getColumnIndex(\"Symbol\")\n        symbol_del = ComboBoxDelegate(self.ui.traces_tbl, symbols)\n        self.ui.traces_tbl.setItemDelegateForColumn(symbol_col, symbol_del)\n\n        size_data = {f\"{i}px\": i for i in range(5, 26, 5)}\n        symbol_size_col = self.curves_model.getColumnIndex(\"Symbol Size\")\n        symbol_size_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n        self.ui.traces_tbl.setItemDelegateForColumn(symbol_size_col, symbol_size_del)\n\n        delete_col = self.curves_model.getColumnIndex(\"\")\n        delete_row_del = DeleteRowDelegate(self.ui.traces_tbl)\n        self.ui.traces_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n\n    @Slot(QPoint)\n    def custom_context_menu(self, pos: QPoint) -&gt; None:\n        \"\"\"Open a custom context menu for the Traces table where the\n        user right-clicks. If the ColorButton is right-clicked, then do\n        not open a context menu.\n\n        Parameters\n        ----------\n        pos : QPoint\n            The position where the context menu should appear\n        \"\"\"\n        table = self.ui.traces_tbl\n        if not table or not isinstance(table, QTableView):\n            logger.error(f\"Internal error: {type(table)} is not QTableView\")\n            return\n\n        index = table.indexAt(pos)\n        is_color = index.column() == self.curves_model.getColumnIndex(\"Color\")\n        logger.debug(f\"ColorButton column selected: {is_color}\")\n\n        if index.isValid() and not is_color:\n            logger.debug(f\"Opening context menu at index {index}\")\n            self.menu.selected_index = index\n            self.menu.popup(table.viewport().mapToGlobal(pos))\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.TracesTableMixin.curve_delegates_init","title":"<code>curve_delegates_init()</code>","text":"<p>Set column delegates for the Traces table to display widgets.</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>def curve_delegates_init(self) -&gt; None:\n    \"\"\"Set column delegates for the Traces table to display widgets.\"\"\"\n    axis_col = self.curves_model.getColumnIndex(\"Y-Axis Name\")\n    axis_combo_del = ComboBoxDelegate(self.ui.traces_tbl, self.axis_table_model)\n    self.ui.traces_tbl.setItemDelegateForColumn(axis_col, axis_combo_del)\n\n    color_col = self.curves_model.getColumnIndex(\"Color\")\n    color_button_del = ColorButtonDelegate(self.ui.traces_tbl)\n    self.ui.traces_tbl.setItemDelegateForColumn(color_col, color_button_del)\n\n    style_col = self.curves_model.getColumnIndex(\"Style\")\n    style_combo_del = ComboBoxDelegate(self.ui.traces_tbl, {\"Direct\": None, \"Step\": \"right\"})\n    self.ui.traces_tbl.setItemDelegateForColumn(style_col, style_combo_del)\n\n    styles = BasePlotCurveItem.lines\n    line_style_col = self.curves_model.getColumnIndex(\"Line Style\")\n    line_style_del = ComboBoxDelegate(self.ui.traces_tbl, styles)\n    self.ui.traces_tbl.setItemDelegateForColumn(line_style_col, line_style_del)\n\n    size_data = {f\"{i}px\": i for i in range(1, 6)}\n    line_width_col = self.curves_model.getColumnIndex(\"Line Width\")\n    line_width_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n    self.ui.traces_tbl.setItemDelegateForColumn(line_width_col, line_width_del)\n\n    symbols = BasePlotCurveItem.symbols\n    symbol_col = self.curves_model.getColumnIndex(\"Symbol\")\n    symbol_del = ComboBoxDelegate(self.ui.traces_tbl, symbols)\n    self.ui.traces_tbl.setItemDelegateForColumn(symbol_col, symbol_del)\n\n    size_data = {f\"{i}px\": i for i in range(5, 26, 5)}\n    symbol_size_col = self.curves_model.getColumnIndex(\"Symbol Size\")\n    symbol_size_del = ComboBoxDelegate(self.ui.traces_tbl, size_data)\n    self.ui.traces_tbl.setItemDelegateForColumn(symbol_size_col, symbol_size_del)\n\n    delete_col = self.curves_model.getColumnIndex(\"\")\n    delete_row_del = DeleteRowDelegate(self.ui.traces_tbl)\n    self.ui.traces_tbl.setItemDelegateForColumn(delete_col, delete_row_del)\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.TracesTableMixin.custom_context_menu","title":"<code>custom_context_menu(pos)</code>","text":"<p>Open a custom context menu for the Traces table where the user right-clicks. If the ColorButton is right-clicked, then do not open a context menu.</p>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.TracesTableMixin.custom_context_menu--parameters","title":"Parameters","text":"<p>pos : QPoint     The position where the context menu should appear</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>@Slot(QPoint)\ndef custom_context_menu(self, pos: QPoint) -&gt; None:\n    \"\"\"Open a custom context menu for the Traces table where the\n    user right-clicks. If the ColorButton is right-clicked, then do\n    not open a context menu.\n\n    Parameters\n    ----------\n    pos : QPoint\n        The position where the context menu should appear\n    \"\"\"\n    table = self.ui.traces_tbl\n    if not table or not isinstance(table, QTableView):\n        logger.error(f\"Internal error: {type(table)} is not QTableView\")\n        return\n\n    index = table.indexAt(pos)\n    is_color = index.column() == self.curves_model.getColumnIndex(\"Color\")\n    logger.debug(f\"ColorButton column selected: {is_color}\")\n\n    if index.isValid() and not is_color:\n        logger.debug(f\"Opening context menu at index {index}\")\n        self.menu.selected_index = index\n        self.menu.popup(table.viewport().mapToGlobal(pos))\n</code></pre>"},{"location":"traces_table/#archive_viewer.mixins.traces_table.TracesTableMixin.traces_table_init","title":"<code>traces_table_init()</code>","text":"<p>Initialize the Traces table model and section.</p> Source code in <code>archive_viewer/mixins/traces_table.py</code> <pre><code>def traces_table_init(self) -&gt; None:\n    \"\"\"Initialize the Traces table model and section.\"\"\"\n    self.curves_model = ArchiverCurveModel(self, self.ui.archiver_plot, self.axis_table_model)\n    self.ui.traces_tbl.setModel(self.curves_model)\n\n    self.menu = PVContextMenu(self)\n    self.ui.traces_tbl.customContextMenuRequested.connect(self.custom_context_menu)\n\n    hdr = self.ui.traces_tbl.horizontalHeader()\n    hdr.setSectionResizeMode(QHeaderView.Stretch)\n    channel_col = self.curves_model.getColumnIndex(\"Channel\")\n    hdr.setSectionResizeMode(channel_col, QHeaderView.ResizeToContents)\n    del_col = self.curves_model.getColumnIndex(\"\")\n    hdr.setSectionResizeMode(del_col, QHeaderView.ResizeToContents)\n</code></pre>"}]}