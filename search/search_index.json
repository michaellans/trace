{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Archive Viewer","text":"<p>The Archive Viewer is a python application </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"installation/","title":"Installing Archive Viewer","text":""},{"location":"main/","title":"Main","text":""},{"location":"pv_table/","title":"PV Table","text":""},{"location":"pv_table/#archive_viewer.pv_table.PVTable","title":"<code>PVTable</code>","text":"<p>             Bases: <code>QWidget</code></p> <p>The PVTable,</p>"},{"location":"pv_table/#archive_viewer.pv_table.PVTable--parameters","title":"Parameters","text":"<p>parent : QWidget   The parent widget for the table macros : str, optional</p> list, optional <p>list of strings that sets the header names for the table.</p> <p>max_rows : int, optional   max number of rows for the table. number_columns : int, optional   number of columns in the table</p> Source code in <code>archive_viewer/pv_table.py</code> <pre><code>class PVTable(QWidget):\n\"\"\"\n    The PVTable,\n\n    Parameters\n    ----------\n    parent : QWidget\n      The parent widget for the table\n    macros : str, optional\n\n    table_headers : list, optional\n      list of strings that sets the header names for the table.\n    max_rows : int, optional\n      max number of rows for the table.\n    number_columns : int, optional\n      number of columns in the table\n    \"\"\"\n\n    send_data_change_signal = QtCore.Signal()\n\n    def __init__(self, macros=None, table_headers=[], max_rows=1, number_columns=8, col_widths=[50]):\n        super().__init__()\n        self.data = PVList()\n        self.data.set_callback(self.data_changed)\n        self.main_layout = QVBoxLayout()\n        self.setLayout(self.main_layout)\n        self.spacer = QSpacerItem(100, 10, QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)\n        self.widget_list = [\n            PyDMLineEdit(),\n            QComboBox(),\n            QComboBox(),\n            QCheckBox(),\n            QCheckBox(),\n            QPushButton(),\n            QComboBox(),\n            QSlider(orientation=QtCore.Qt.Horizontal),\n        ]\n        self.table_headers = table_headers\n        self.table = None\n        self.number_columns = number_columns\n        self.max_rows = max_rows\n        self.col_widths = col_widths\n        self.make_frame()\n        self.setup_table()\n        self.last_clicked_index = None  # Add this line\n        self.contextMenu = PVContextMenu(self)\n        self.contextMenu.data_changed_signal.connect(self.handle_delete_pv_row)\n\n        if macros:\n            self.macros = macros\n            if \"PV\" in self.macros.keys():\n                try:\n                    self.table.cellWidget(0, 0).setText(macros[\"PV\"])\n                    self.passPV(0)\n                except Exception:\n                    print(\"Error with loading single PV\")\n            elif \"CSV\" in self.macros.keys():\n                try:\n                    self.applyCSVFile(macros[\"CSV\"])\n                except Exception:\n                    print(\"Error: File not found\")\n        else:\n            self.macros = {\"PV\": \"\", \"CSV\": \"\"}\n\n    def mousePressEvent(self, event):\n        if event.button() == QtCore.Qt.RightButton:\n            position = event.pos()\n            index = self.table.indexAt(position)\n\n            if index.isValid():\n                self.last_clicked_index = index  # Store the clicked index\n                self.show_context_menu(index, event.globalPos())\n\n        super().mousePressEvent(event)\n\n    def remove_row(self, index):\n        if 0 &lt;= index &lt; len(self.data):\n            self.data.pop(index)\n            self.table.removeRow(index)\n\n    def show_context_menu(self, index, global_position):\n        context_menu = PVContextMenu(self)\n        context_menu.data_changed_signal.connect(self.handle_delete_pv_row)\n        context_menu.index = index.row()  # Store the row index for deletion\n        context_menu.exec_(global_position)\n\n\"\"\"\n    def show_context_menu(self, point):\n        index = self.table.indexAt(point)\n        if index.isValid():\n            row = index.row()\n            self.contextMenu.index = row  # Update the stored index in the context menu\n            self.contextMenu.exec_(self.table.viewport().mapToGlobal(point))\n    \"\"\"\n\n    def data_menu(self, position_of_click):\n        self.archive_search = ArchiveSearchWidget()\n        self.archive_search.move(self.mapToGlobal(position_of_click))\n        self.archive_search.show()\n\n    def handle_delete_pv_row(self, row):\n        if row &lt; 0 or row &gt;= len(self.data):\n            return\n\n        self.data[row][0]  # Assuming the PV name is stored at index 0 in the data list (adjust as needed)\n        self.remove_row(row)\n        self.send_data_change_signal.emit()\n\n    def make_frame(self) -&gt; None:\n        self.table_frame = QFrame()\n        self.table_frame_layout = QVBoxLayout()\n        self.table_frame.setLayout(self.table_frame_layout)\n        self.main_layout.addWidget(self.table_frame)\n\n    def setup_table(self):\n        self.table = QTableWidget()\n        self.table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)\n        self.table.setRowCount(self.max_rows)\n        self.table.setColumnCount(self.number_columns)\n\n        if len(self.col_widths) == 1:\n            self.col_widths = self.col_widths * self.table.columnCount()\n        if len(self.col_widths) &lt; self.table.columnCount():\n            pass\n\n        # Set the row headers with letters\n        for row_index in range(self.table.rowCount()):\n            letter = self.get_letter(row_index)\n            self.table.setVerticalHeaderItem(row_index, QTableWidgetItem(letter))\n\n        # col_widths = [200, 200, 80, 80, 100, 80, 160, 40, 60, 80]\n        for i in range(self.table.columnCount()):\n            self.table.setColumnWidth(i, self.col_widths[i])\n\n        self.table.setHorizontalHeaderLabels(self.table_headers)\n        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)\n        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)\n        self.table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)\n        self.table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)\n\n        for i in range(self.table.rowCount()):\n            self.setupRow(i)\n\n        self.table_frame_layout.addWidget(self.table)\n\n        # Set context menu policy for the entire table\n        self.table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n\n        # Connect context menu to the table's customContextMenuRequested signal\n        self.table.customContextMenuRequested.connect(self.show_context_menu)\n\n    def setupRow(self, index):\n        for i in range(0, self.table.columnCount()):\n            obj = [\n                QLineEdit(),\n                QComboBox(),\n                QCheckBox(),\n                QCheckBox(),\n                QPushButton(),\n                QComboBox(),\n                QSlider(orientation=QtCore.Qt.Horizontal),\n            ]\n\n            # if i == 1:  # Time Axis drop-down menu\n            #     time_axes_names = [axis[\"axis_name\"] for axis in self.time_axes]\n            #     obj[i].addItems(time_axes_names)\n\n            if i == 4:  # Color column\n                color_button = QPushButton()\n                color_button.setStyleSheet(\"background-color: white\")\n                color_button.clicked.connect(partial(self.openColorPicker, index, color_button))\n                self.table.setCellWidget(index, i, color_button)\n            else:\n                self.table.setCellWidget(index, i, obj[i])\n        # establish signals\n        self.table.cellWidget(index, 0).textChanged.connect(\n            partial(partial(self.update_data, index, 0, self.table.cellWidget(index, 0).text))\n        )\n\n        self.table.cellWidget(index, 1).currentIndexChanged.connect(\n            partial(self.update_data, index, 1, self.table.cellWidget(index, 1).currentText())\n        )\n        # self.table.cellWidget(index, 2).currentIndexChanged.connect(partial(self.update_data, index, 2,\n        #                                                             self.table.cellWidget(index, 2).currentText()))\n        self.table.cellWidget(index, 2).stateChanged.connect(\n            partial(self.update_data, index, 2, self.table.cellWidget(index, 2).checkState)\n        )\n        # Set the initial state of the \"Visible\" checkbox to checked\n        self.table.cellWidget(index, 2).setChecked(True)\n        self.table.cellWidget(index, 3).stateChanged.connect(\n            partial(self.update_data, index, 3, self.table.cellWidget(index, 3).checkState)\n        )\n        # self.table.cellWidget(index, 5).currentIndexChanged.connect(partial(self.update_data, index, 5,\n        # self.table.cellWidget(index, 5).currentText()))\n        self.table.cellWidget(index, 5).currentIndexChanged.connect(\n            partial(self.update_data, index, 5, self.table.cellWidget(index, 5).currentText())\n        )\n        self.table.cellWidget(index, 6).valueChanged.connect(\n            partial(self.update_data, index, 6, self.table.cellWidget(index, 6).value)\n        )\n\n        letter = self.get_letter(index)\n        self.table.setVerticalHeaderItem(index, QTableWidgetItem(letter))\n\n        self.data.append(\n            PVList(\n                [\n                    self.table.cellWidget(index, 0).text(),\n                    self.table.cellWidget(index, 1).currentText(),\n                    self.table.cellWidget(index, 2).checkState(),\n                    self.table.cellWidget(index, 3).checkState(),\n                    0,\n                    self.table.cellWidget(index, 5).currentText(),\n                    self.table.cellWidget(index, 6).value(),\n                ]\n            )\n        )\n\n        self.data[-1].set_callback(self.data_changed)\n\n    def get_letter(self, index):\n        if index &lt; 26:\n            return chr(ord(\"A\") + index)\n        else:\n            div = index // 26\n            mod = index % 26\n            return chr(ord(\"A\") + div - 1) + chr(ord(\"A\") + mod)\n\n    def update_data(self, index, position, value):\n        print(index, position, value)\n        self.add_Row(index)\n        try:\n            if isinstance(self.table.cellWidget(index, position), QComboBox):\n                self.data[index][position] = value\n            elif isinstance(self.table.cellWidget(index, position), QPushButton):\n                color_button = self.table.cellWidget(index, position)\n                color_style = color_button.styleSheet()\n                match = re.search(r\"background-color: (.*?);\", color_style)\n                if match:\n                    color = match.group(1)\n                    self.data[index][position] = color\n        except IndexError:\n            print(\"Error: Invalid index\")\n\n    def add_Row(self, index):\n        if index != len(self.data) - 1:\n            return\n\n        current_row_count = self.table.rowCount()\n        current_row_count += 1\n        self.table.setRowCount(current_row_count)\n        self.setupRow(current_row_count - 1)\n\n        # Set the row header for the newly added row\n        letter = self.get_letter(current_row_count - 1)\n        self.table.setVerticalHeaderItem(current_row_count - 1, QTableWidgetItem(letter))\n\n    def resetRow(self, index):\n        if not self.widget_list:\n            return False\n\n        obj = [\n            PyDMLineEdit(),\n            QComboBox(),\n            QCheckBox(),\n            QCheckBox(),\n            QPushButton(),\n            QComboBox(),\n            QSlider(orientation=QtCore.Qt.Horizontal),\n        ]\n\n        for i in range(0, self.table.columnCount()):\n            self.table.setCellWidget(index, i, obj[i])\n\n\"\"\"\n        for j in range(1, self.table.columnCount()):\n            self.table.setCellWidget(index, j, PyDMLabel(' '))\n            self.table.cellWidget(index, j).setText(None)\n            self.table.cellWidget(index, j).setAlignment(QtCore.Qt.AlignCenter)\n        self.table.cellWidget(index, 2).setProperty('precisionFromPV', True)\n        self.table.removeCellWidget(index, 4)\n        self.table.setItem(index, 4, QTableWidgetItem())\n        self.table.setCellWidget(index, 7, QPushButton('Save'))\n        self.table.setCellWidget(index, 8, QPushButton('Restore'))\n        self.table.setCellWidget(index, 9, PyDMLineEdit())\n        self.table.cellWidget(index, 7).clicked.connect(partial(self.savePV, index))\n        self.table.cellWidget(index, 8).clicked.connect(partial(self.restorePV, index))\n        \"\"\"\n\n    def passPV(self, index):\n        self.data = self.table.cellWidget(index, 0).text()\n\n\"\"\"\n        if '#' in pv:\n            self.resetRow(index)\n            strings = pv.split('#')\n            colors = ['white', 'cyan', 'darkcyan', 'red', 'darkred', 'magenta', 'darkmagenta', 'green', 'darkgreen',\n                      'yellow', 'gray', 'darkgray', 'lightgray', 'blue', 'darkblue', 'black']\n            darkcolors = ['green', 'darkgreen', 'blue', 'darkblue', 'black', 'darkred', 'darkmagenta', 'red']\n            for split in strings:\n                if split in colors:\n                    style = 'font-weight: bold; background-color: ' + split\n                    for i in range(4):\n                        self.table.cellWidget(index, i).setStyleSheet(style)\n                    for i in range(4,5):\n                        pass\n                        # self.table.item(index, i).setBackground(QColor(split))\n                    for i in range(5,7):\n                        self.table.cellWidget(index, i).setStyleSheet(style)\n                if split in darkcolors:\n                    font = style + '; color: white;'\n                    self.table.cellWidget(index, 0).setStyleSheet(font)\n        elif pv == '':\n            pass\n            self.resetRow(index)\n        else:\n            for i in range(4):\n                self.table.cellWidget(index, i).setStyleSheet(None)\n            for i in range(4,5):\n                pass\n                # self.table.item(index, i).setBackground(QColor('transparent'))\n            for i in range(5, self.number_columns):\n                self.table.cellWidget(index, i).setStyleSheet(None)\n            self.table.cellWidget(index, 1).channel = pv + '.DESC'\n            self.table.cellWidget(index, 2).channel = pv\n            self.table.cellWidget(index, 3).channel = pv + '.SEVR'\n            self.chan1 = PyDMChannel(self.table.cellWidget(index, 2).channel, value_slot=partial(self.differenceCalc,\n                                                                                                 foobar=index))\n            self.chan1.connect()\n            self.chan1.connect()\n            self.table.cellWidget(index, self.number_columns).channel = pv\n        \"\"\"\n\n    def savePV(self, index):\n        ## Check that channel is connected\n        if self.table.cellWidget(index, 2).channel:\n            value = self.table.cellWidget(index, 2).text()\n            self.table.item(index, 4).setText(value)\n            now = datetime.now()\n            dt_string = now.strftime(\"%m/%d/%Y %H:%M:%S\")\n            self.table.cellWidget(index, 6).setText(dt_string)\n            self.table.item(index, 4).setBackground(QtGui.QColor(159, 157, 154))\n\n    def saveAll(self):\n        for i in range(self.table.rowCount()):\n            self.savePV(i)\n\n    def restorePV(self, index):\n        if self.table.item(index, 4).text():\n            value = self.table.item(index, 4).text()\n            pv = epics.PV(self.table.cellWidget(index, 0).text())\n            pv.put(value)\n\n    def restoreAll(self):\n        pv_list = []\n        value_list = []\n        for i in range(self.table.rowCount()):\n            if self.table.item(i, 4).text():\n                try:\n                    value = self.table.item(i, 4).text()\n                    value = float(value)\n                    value_list.append(value)\n                    pv = self.table.cellWidget(i, 0).text()\n                    pv_list.append(pv)\n                    epics.caput_many(pv_list, value_list)\n                except Exception:\n                    pass\n\n    def differenceCalc(self, new_val, foobar):\n        live = self.table.cellWidget(foobar, 2).text()\n        saved = self.table.item(foobar, 4).text()\n        if saved:\n            self.table.item(foobar, 4).setBackground(QtGui.QColor(159, 157, 154))\n            if live != saved:\n                self.table.item(foobar, 4).setBackground(QtGui.QColor(255, 157, 154))\n            try:\n                live = float(live)\n                saved = float(saved)\n                diff = live - saved\n                self.table.cellWidget(foobar, 5).setText(str(diff))\n            except Exception:\n                pass\n\n    def setupHeader(self):\n        self.header_frame[0].setMaximumHeight(40)\n\n        QLabel(\"Number of Rows:\")\n        self.row_spin = QSpinBox()\n        self.row_spin.setValue(10)\n        self.row_spin.setKeyboardTracking(False)\n        self.row_spin.setRange(1, 200)\n        self.row_spin.valueChanged.connect(self.editRows)\n\n        QLabel(\"Filter:\")\n        self.fltr_edit = QLineEdit()\n        self.fltr_edit.returnPressed.connect(self.doSearch)\n        fltr_btn = QPushButton(\"Search\")\n        fltr_btn.clicked.connect(self.doSearch)\n        fltr_rst_btn = QPushButton(\"Reset\")\n        fltr_rst_btn.clicked.connect(self.resetSearch)\n\n        QLabel(\"Menu:\")\n        self.combo_btn = QComboBox()\n        combo_items = [\n            \"Export to CSV\",\n            \"Load Snapshot\",\n            \"Load with eget\",\n            \"Clear Saves (Confirm)\",\n            \"Clear Table (Confirm)\",\n        ]\n        self.combo_btn.addItems(combo_items)\n        self.combo_btn.activated.connect(self.comboChoice)\n\n    def editRows(self):\n        new_num_rows = self.row_spin.value()\n        total_num_rows = self.table.rowCount()\n\n        for i in range(total_num_rows):\n            self.table.hideRow(i)\n        for i in range(new_num_rows):\n            self.table.showRow(i)\n\n        # if new_num_rows &gt; 199:\n        #   self.insert_btn.setEnabled(False)\n        # else:\n        #   self.insert_btn.setEnabled(True)\n\n    def doSearch(self):\n        search_text = self.fltr_edit.text()\n        if search_text == \"\":\n            self.editRows()\n        for i in range(self.table.rowCount()):\n            pv = self.table.cellWidget(i, 0).text()\n            if search_text.upper() not in pv.upper():\n                self.table.hideRow(i)\n\n    def resetSearch(self):\n        self.fltr_edit.setText(\"\")\n        self.editRows()\n\n    def comboChoice(self):\n        if self.combo_btn.currentIndex() == 0:\n            self.exportToCSV()\n        elif self.combo_btn.currentIndex() == 1:\n            self.loadSnapshot()\n        elif self.combo_btn.currentIndex() == 2:\n            self.showEGETFrame()\n        elif self.combo_btn.currentIndex() == 3:\n            self.clearConfirm(self.clearSaves, \"Saves\")\n        elif self.combo_btn.currentIndex() == 4:\n            self.clearConfirm(self.clearTable, \"Table\")\n\n    def exportToCSV(self):\n        list_data = []\n        shown_rows = int(self.row_spin.text())\n        for i in range(shown_rows):\n            list_row = []\n            for j in range(self.table.columnCount()):\n                if j in [0, 1, 2, 3, 5, 6, 9, 10]:\n                    cell_text = self.table.cellWidget(i, j).text()\n                    if not cell_text:\n                        cell_text = \" \"\n                elif j == 4:\n                    cell_text = self.table.item(i, j).text()\n                    if not cell_text:\n                        cell_text = \" \"\n                elif j in [7, 8]:\n                    cell_text = \" \"\n                list_row.append(cell_text)\n            list_data.append(list_row)\n        df = pd.DataFrame(list_data, columns=self.table_headers)\n        file_dialog = QFileDialog()\n        file_dialog.setDefaultSuffix(\".csv\")\n        try:\n            csv_file = file_dialog.getSaveFileName(self, \"Save File\", \"\", \"Comma-separated values (*.csv)\")[0]\n            df.to_csv(csv_file)\n        except IOError:\n            pass\n\n    def loadSnapshot(self):\n        file_dialog = QFileDialog()\n        try:\n            csv_file = file_dialog.getOpenFileName(self, \"Open File\", \"\", \"Comma-separated values (*.csv)\")\n\n            if csv_file != \"\":\n                self.applyCSVFile(csv_file[0])\n\n        except IOError:\n            pass\n\n    def applyCSVFile(self, filename):\n        df = pd.read_csv(filename)\n        pvs = list(df.PV)\n        self.clearTable()\n        self.row_spin.setValue(len(pvs))\n\n        for i in range(len(pvs)):\n            self.table.cellWidget(i, 0).setText(str(df.PV.iloc[i]))\n            self.table.item(i, 4).setText(str(df[\"Saved Value\"].iloc[i]))\n            self.table.cellWidget(i, 6).setText(str(df[\"Save Timestamp\"].iloc[i]))\n\n    def clearConfirm(self, fxn, items):\n        msg = QMessageBox()\n        msg.setWindowTitle(\"Confirm \" + str(items) + \" Clear\")\n        msg.setText(\"Are you sure you want to clear the \" + items.lower() + \"?\")\n        msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msg.setDefaultButton(QMessageBox.No)\n        msg.buttonClicked.connect(partial(self.clearConfirmClicked, fxn=fxn))\n        msg.exec_()\n\n    def clearConfirmClicked(self, i, fxn):\n        button_clicked = i.text()\n        if button_clicked == \"&amp;Yes\":\n            fxn()\n\n    def clearTable(self):\n        self.table.deleteLater()\n        self.setup_table()\n        self.editRows()\n\n    def clearSaves(self):\n        for i in range(self.table.rowCount()):\n            if self.table.item(i, 4).text():\n                self.table.item(i, 4).setText(\"\")\n                self.table.item(i, 4).setBackground(QtGui.QColor(159, 157, 154))\n                self.table.cellWidget(i, 5).setText(\"\")\n                self.table.cellWidget(i, 6).setText(\"\")\n\n    def setupFooter(self):\n        self.footer_frame[0].setMaximumHeight(40)\n        # insert_lbl = QLabel('Insert Row Below:')\n        # self.insert_spin = QSpinBox()\n        # self.insert_spin.setRange(1,199)\n        # self.insert_btn = QPushButton('Insert Row')\n        # self.insert_btn.clicked.connect(self.insertRow)\n\n        save_all_btn = QPushButton(\"Save All\")\n        save_all_btn.clicked.connect(self.saveAll)\n\n        restore_all_btn = QPushButton(\"Restore All\")\n        restore_all_btn.setEnabled(False)\n        # restore_all_btn.clicked.connect(self.restoreAll)\n\n\"\"\"\n        helpfile = 'pv_table_help.ui'\n        help_btn = PyDMRelatedDisplayButton('Help...', filename = helpfile)\n        help_btn.setMaximumWidth(80)\n        help_btn.setProperty('openInNewWindow', True)\n        \"\"\"\n\n        # footer_widgets = [self.spacer, save_all_btn, restore_all_btn, help_btn]\n        # footer_widgets = [self.spacer, save_all_btn, restore_all_btn]\n\n    # def insertRow(self):\n    #   insert_row = self.insert_spin.value()\n    #  num_rows = self.row_spin.value() + 1\n    # self.table.insertRow(insert_row)\n    # for i in range(insert_row, num_rows):\n    #   self.setupRow(i)\n    # self.row_spin.setValue(num_rows)\n\n    def openColorPicker(self, index, button_widget):\n        color_dialog = QColorDialog()\n        color = color_dialog.getColor()\n\n        if color.isValid():\n            button_widget.setStyleSheet(f\"background-color: {color.name()}\")\n            self.update_data(index, 5, color.name())\n\n    def contextMenuEvent(self, event):\n        if self.last_clicked_index is not None:\n            index = self.last_clicked_index\n\n            context_menu = PVContextMenu(self)\n            context_menu.data_changed_signal.connect(self.handle_delete_pv_row)\n            context_menu.index = index.row()  # Store the row index for deletion\n            context_menu.exec_(event.globalPos())\n\n    def data_changed(self):\n        self.send_data_change_signal.emit()\n</code></pre>"}]}